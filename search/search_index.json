{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"omnigraph API Documentation","text":""},{"location":"#omnigraph.blazegraph","title":"<code>blazegraph</code>","text":""},{"location":"#omnigraph.blazegraph.Blazegraph","title":"<code>Blazegraph</code>","text":"<p>               Bases: <code>SparqlServer</code></p> <p>Dockerized Blazegraph SPARQL server</p> Source code in <code>omnigraph/blazegraph.py</code> <pre><code>class Blazegraph(SparqlServer):\n    \"\"\"\n    Dockerized Blazegraph SPARQL server\n    \"\"\"\n\n    def __init__(\n        self,\n        config: ServerConfig,\n        env: ServerEnv\n    ):\n        \"\"\"\n        Initialize the Blazegraph manager.\n\n        Args:\n            config: Server configuration\n            env: Server environment (includes log, shell, debug, verbose)\n        \"\"\"\n        super().__init__(config=config, env=env)\n        self.dataloader_url = f\"{self.config.base_url}/dataloader\"\n\n    def status(self) -&gt; dict:\n        \"\"\"\n        Get Blazegraph status information.\n\n        Returns:\n            Dictionary with status information, empty dict if error\n        \"\"\"\n        status_dict = {}\n\n        result = self._make_request(\"GET\", self.config.status_url, timeout=2)\n\n        if result[\"success\"]:\n            status_dict[\"status\"] = \"ready\"\n            html_content = result[\"content\"]\n            name_value_pattern = r'(?:&lt;span id=\"(?P&lt;name1&gt;[^\"]+)\"&gt;(?P&lt;value1&gt;[^&lt;]+)&lt;/span[^&gt;]*&gt;|&amp;#47;(?P&lt;name2&gt;[^=]+)=(?P&lt;value2&gt;[^\\s&amp;#]+))'\n            matches = re.finditer(name_value_pattern, html_content, re.DOTALL)\n\n            for match in matches:\n                for name_group, value_group in {\n                    \"name1\": \"value1\",\n                    \"name2\": \"value2\",\n                }.items():\n                    name = match.group(name_group)\n                    if name:\n                        value = match.group(value_group)\n                        sanitized_value = value.replace(\"&lt;/p\", \"\").replace(\"&amp;#47;\", \"/\")\n                        sanitized_name = name.replace(\"-\", \"_\").replace(\"/\", \"_\")\n                        sanitized_name = sanitized_name.replace(\"&amp;#47;\", \"/\")\n                        if not sanitized_name.startswith(\"/\"):\n                            status_dict[sanitized_name] = sanitized_value\n                        break\n        else:\n            if result.get(\"error\"):\n                status_dict[\"status\"] = f\"error: {result['error']}\"\n            else:\n                status_dict[\"status\"] = f\"status_code: {result['status_code']}\"\n\n        return status_dict\n\n    def load_file(self, filepath: str) -&gt; bool:\n        \"\"\"\n        Load a single RDF file into Blazegraph.\n\n        Args:\n            filepath: Path to RDF file\n\n        Returns:\n            True if loaded successfully\n        \"\"\"\n        load_success = False\n        try:\n            with open(filepath, \"rb\") as f:\n                result = self._make_request(\n                    \"POST\",\n                    self.config.sparql_url,\n                    headers={\"Content-Type\": \"text/turtle\"},\n                    data=f.read(),\n                    timeout=300,\n                )\n\n            if result[\"success\"]:\n                self.log.log(\"\u2705\", self.name, f\"Loaded {filepath}\")\n                load_success = True\n            else:\n                error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n                self.log.log(\"\u274c\", self.name, f\"Failed to load {filepath}: {error_msg}\")\n                load_success = False\n\n        except Exception as e:\n            self.log.log(\"\u274c\", self.name, f\"Exception loading {filepath}: {e}\")\n            load_success = False\n\n        return load_success\n\n    def load_files_bulk(self, file_list: list) -&gt; bool:\n        \"\"\"\n        Load multiple files using Blazegraph's bulk loader REST API.\n\n        Args:\n            file_list: List of file paths to load\n\n        Returns:\n            True if loaded successfully\n        \"\"\"\n        bulk_load_success = False\n\n        if not file_list:\n            bulk_load_success = False\n        else:\n            # Convert to absolute paths\n            abs_paths = [str(Path(f).absolute()) for f in file_list]\n\n            properties = f\"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n            &lt;properties&gt;\n                &lt;entry key=\"format\"&gt;turtle&lt;/entry&gt;\n                &lt;entry key=\"quiet\"&gt;false&lt;/entry&gt;\n                &lt;entry key=\"verbose\"&gt;1&lt;/entry&gt;\n                &lt;entry key=\"namespace\"&gt;kb&lt;/entry&gt;\n                &lt;entry key=\"fileOrDirs\"&gt;{','.join(abs_paths)}&lt;/entry&gt;\n            &lt;/properties&gt;\"\"\"\n\n            result = self._make_request(\n                \"POST\",\n                self.dataloader_url,\n                headers={\"Content-Type\": \"application/xml\"},\n                data=properties,\n                timeout=3600,\n            )\n\n            if result[\"success\"]:\n                self.log.log(\"\u2705\", self.container_name, f\"Bulk loaded {len(file_list)} files\")\n                bulk_load_success = True\n            else:\n                error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n                self.log.log(\"\u274c\", self.container_name, f\"Bulk load failed: {error_msg}\")\n                bulk_load_success = False\n\n        return bulk_load_success\n\n    def load_dump_files(self, file_pattern: str = \"dump_*.ttl\", use_bulk: bool = True) -&gt; int:\n        \"\"\"\n        Load all dump files matching pattern.\n\n        Args:\n            file_pattern: Glob pattern for dump files\n            use_bulk: Use bulk loader if True, individual files if False\n\n        Returns:\n            Number of files loaded successfully\n        \"\"\"\n        files = sorted(glob.glob(file_pattern))\n        loaded_count = 0\n\n        if not files:\n            self.log.log(\n                \"\u26a0\ufe0f\",\n                self.container_name,\n                f\"No files found matching pattern: {file_pattern}\",\n            )\n            loaded_count = 0\n        else:\n            self.log.log(\"\u2705\", self.container_name, f\"Found {len(files)} files to load\")\n\n            if use_bulk:\n                bulk_result = self.load_files_bulk(files)\n                loaded_count = len(files) if bulk_result else 0\n            else:\n                loaded_count = 0\n                for filepath in tqdm(files, desc=\"Loading files\"):\n                    file_result = self.load_file(filepath)\n                    if file_result:\n                        loaded_count += 1\n                    else:\n                        self.log.log(\"\u274c\", self.container_name, f\"Failed to load: {filepath}\")\n\n        return loaded_count\n\n    def test_geosparql(self) -&gt; bool:\n        \"\"\"\n        Test if GeoSPARQL functions work.\n\n        Returns:\n            True if GeoSPARQL is available\n        \"\"\"\n        test_query = \"\"\"\n        PREFIX geo: &lt;http://www.opengis.net/ont/geosparql#&gt;\n        PREFIX geof: &lt;http://www.opengis.net/def/function/geosparql/&gt;\n\n        SELECT * WHERE {\n            BIND(geof:distance(\"POINT(0 0)\"^^geo:wktLiteral, \"POINT(1 1)\"^^geo:wktLiteral) AS ?dist)\n        } LIMIT 1\n        \"\"\"\n\n        result = self._make_request(\n            \"POST\",\n            self.sparql_url,\n            data={\"query\": test_query},\n            headers={\"Accept\": \"application/sparql-results+json\"},\n            timeout=10,\n        )\n\n        geosparql_available = result[\"success\"]\n        return geosparql_available\n</code></pre>"},{"location":"#omnigraph.blazegraph.Blazegraph.__init__","title":"<code>__init__(config, env)</code>","text":"<p>Initialize the Blazegraph manager.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ServerConfig</code> <p>Server configuration</p> required <code>env</code> <code>ServerEnv</code> <p>Server environment (includes log, shell, debug, verbose)</p> required Source code in <code>omnigraph/blazegraph.py</code> <pre><code>def __init__(\n    self,\n    config: ServerConfig,\n    env: ServerEnv\n):\n    \"\"\"\n    Initialize the Blazegraph manager.\n\n    Args:\n        config: Server configuration\n        env: Server environment (includes log, shell, debug, verbose)\n    \"\"\"\n    super().__init__(config=config, env=env)\n    self.dataloader_url = f\"{self.config.base_url}/dataloader\"\n</code></pre>"},{"location":"#omnigraph.blazegraph.Blazegraph.load_dump_files","title":"<code>load_dump_files(file_pattern='dump_*.ttl', use_bulk=True)</code>","text":"<p>Load all dump files matching pattern.</p> <p>Parameters:</p> Name Type Description Default <code>file_pattern</code> <code>str</code> <p>Glob pattern for dump files</p> <code>'dump_*.ttl'</code> <code>use_bulk</code> <code>bool</code> <p>Use bulk loader if True, individual files if False</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of files loaded successfully</p> Source code in <code>omnigraph/blazegraph.py</code> <pre><code>def load_dump_files(self, file_pattern: str = \"dump_*.ttl\", use_bulk: bool = True) -&gt; int:\n    \"\"\"\n    Load all dump files matching pattern.\n\n    Args:\n        file_pattern: Glob pattern for dump files\n        use_bulk: Use bulk loader if True, individual files if False\n\n    Returns:\n        Number of files loaded successfully\n    \"\"\"\n    files = sorted(glob.glob(file_pattern))\n    loaded_count = 0\n\n    if not files:\n        self.log.log(\n            \"\u26a0\ufe0f\",\n            self.container_name,\n            f\"No files found matching pattern: {file_pattern}\",\n        )\n        loaded_count = 0\n    else:\n        self.log.log(\"\u2705\", self.container_name, f\"Found {len(files)} files to load\")\n\n        if use_bulk:\n            bulk_result = self.load_files_bulk(files)\n            loaded_count = len(files) if bulk_result else 0\n        else:\n            loaded_count = 0\n            for filepath in tqdm(files, desc=\"Loading files\"):\n                file_result = self.load_file(filepath)\n                if file_result:\n                    loaded_count += 1\n                else:\n                    self.log.log(\"\u274c\", self.container_name, f\"Failed to load: {filepath}\")\n\n    return loaded_count\n</code></pre>"},{"location":"#omnigraph.blazegraph.Blazegraph.load_file","title":"<code>load_file(filepath)</code>","text":"<p>Load a single RDF file into Blazegraph.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to RDF file</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully</p> Source code in <code>omnigraph/blazegraph.py</code> <pre><code>def load_file(self, filepath: str) -&gt; bool:\n    \"\"\"\n    Load a single RDF file into Blazegraph.\n\n    Args:\n        filepath: Path to RDF file\n\n    Returns:\n        True if loaded successfully\n    \"\"\"\n    load_success = False\n    try:\n        with open(filepath, \"rb\") as f:\n            result = self._make_request(\n                \"POST\",\n                self.config.sparql_url,\n                headers={\"Content-Type\": \"text/turtle\"},\n                data=f.read(),\n                timeout=300,\n            )\n\n        if result[\"success\"]:\n            self.log.log(\"\u2705\", self.name, f\"Loaded {filepath}\")\n            load_success = True\n        else:\n            error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n            self.log.log(\"\u274c\", self.name, f\"Failed to load {filepath}: {error_msg}\")\n            load_success = False\n\n    except Exception as e:\n        self.log.log(\"\u274c\", self.name, f\"Exception loading {filepath}: {e}\")\n        load_success = False\n\n    return load_success\n</code></pre>"},{"location":"#omnigraph.blazegraph.Blazegraph.load_files_bulk","title":"<code>load_files_bulk(file_list)</code>","text":"<p>Load multiple files using Blazegraph's bulk loader REST API.</p> <p>Parameters:</p> Name Type Description Default <code>file_list</code> <code>list</code> <p>List of file paths to load</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully</p> Source code in <code>omnigraph/blazegraph.py</code> <pre><code>def load_files_bulk(self, file_list: list) -&gt; bool:\n    \"\"\"\n    Load multiple files using Blazegraph's bulk loader REST API.\n\n    Args:\n        file_list: List of file paths to load\n\n    Returns:\n        True if loaded successfully\n    \"\"\"\n    bulk_load_success = False\n\n    if not file_list:\n        bulk_load_success = False\n    else:\n        # Convert to absolute paths\n        abs_paths = [str(Path(f).absolute()) for f in file_list]\n\n        properties = f\"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n        &lt;properties&gt;\n            &lt;entry key=\"format\"&gt;turtle&lt;/entry&gt;\n            &lt;entry key=\"quiet\"&gt;false&lt;/entry&gt;\n            &lt;entry key=\"verbose\"&gt;1&lt;/entry&gt;\n            &lt;entry key=\"namespace\"&gt;kb&lt;/entry&gt;\n            &lt;entry key=\"fileOrDirs\"&gt;{','.join(abs_paths)}&lt;/entry&gt;\n        &lt;/properties&gt;\"\"\"\n\n        result = self._make_request(\n            \"POST\",\n            self.dataloader_url,\n            headers={\"Content-Type\": \"application/xml\"},\n            data=properties,\n            timeout=3600,\n        )\n\n        if result[\"success\"]:\n            self.log.log(\"\u2705\", self.container_name, f\"Bulk loaded {len(file_list)} files\")\n            bulk_load_success = True\n        else:\n            error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n            self.log.log(\"\u274c\", self.container_name, f\"Bulk load failed: {error_msg}\")\n            bulk_load_success = False\n\n    return bulk_load_success\n</code></pre>"},{"location":"#omnigraph.blazegraph.Blazegraph.status","title":"<code>status()</code>","text":"<p>Get Blazegraph status information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with status information, empty dict if error</p> Source code in <code>omnigraph/blazegraph.py</code> <pre><code>def status(self) -&gt; dict:\n    \"\"\"\n    Get Blazegraph status information.\n\n    Returns:\n        Dictionary with status information, empty dict if error\n    \"\"\"\n    status_dict = {}\n\n    result = self._make_request(\"GET\", self.config.status_url, timeout=2)\n\n    if result[\"success\"]:\n        status_dict[\"status\"] = \"ready\"\n        html_content = result[\"content\"]\n        name_value_pattern = r'(?:&lt;span id=\"(?P&lt;name1&gt;[^\"]+)\"&gt;(?P&lt;value1&gt;[^&lt;]+)&lt;/span[^&gt;]*&gt;|&amp;#47;(?P&lt;name2&gt;[^=]+)=(?P&lt;value2&gt;[^\\s&amp;#]+))'\n        matches = re.finditer(name_value_pattern, html_content, re.DOTALL)\n\n        for match in matches:\n            for name_group, value_group in {\n                \"name1\": \"value1\",\n                \"name2\": \"value2\",\n            }.items():\n                name = match.group(name_group)\n                if name:\n                    value = match.group(value_group)\n                    sanitized_value = value.replace(\"&lt;/p\", \"\").replace(\"&amp;#47;\", \"/\")\n                    sanitized_name = name.replace(\"-\", \"_\").replace(\"/\", \"_\")\n                    sanitized_name = sanitized_name.replace(\"&amp;#47;\", \"/\")\n                    if not sanitized_name.startswith(\"/\"):\n                        status_dict[sanitized_name] = sanitized_value\n                    break\n    else:\n        if result.get(\"error\"):\n            status_dict[\"status\"] = f\"error: {result['error']}\"\n        else:\n            status_dict[\"status\"] = f\"status_code: {result['status_code']}\"\n\n    return status_dict\n</code></pre>"},{"location":"#omnigraph.blazegraph.Blazegraph.test_geosparql","title":"<code>test_geosparql()</code>","text":"<p>Test if GeoSPARQL functions work.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if GeoSPARQL is available</p> Source code in <code>omnigraph/blazegraph.py</code> <pre><code>def test_geosparql(self) -&gt; bool:\n    \"\"\"\n    Test if GeoSPARQL functions work.\n\n    Returns:\n        True if GeoSPARQL is available\n    \"\"\"\n    test_query = \"\"\"\n    PREFIX geo: &lt;http://www.opengis.net/ont/geosparql#&gt;\n    PREFIX geof: &lt;http://www.opengis.net/def/function/geosparql/&gt;\n\n    SELECT * WHERE {\n        BIND(geof:distance(\"POINT(0 0)\"^^geo:wktLiteral, \"POINT(1 1)\"^^geo:wktLiteral) AS ?dist)\n    } LIMIT 1\n    \"\"\"\n\n    result = self._make_request(\n        \"POST\",\n        self.sparql_url,\n        data={\"query\": test_query},\n        headers={\"Accept\": \"application/sparql-results+json\"},\n        timeout=10,\n    )\n\n    geosparql_available = result[\"success\"]\n    return geosparql_available\n</code></pre>"},{"location":"#omnigraph.blazegraph.BlazegraphConfig","title":"<code>BlazegraphConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ServerConfig</code></p> <p>Blazegraph configuration</p> Source code in <code>omnigraph/blazegraph.py</code> <pre><code>@dataclass\nclass BlazegraphConfig(ServerConfig):\n    \"\"\"\n    Blazegraph configuration\n    \"\"\"\n\n    def __post_init__(self):\n        super().__post_init__()\n        blazegraph_base = f\"{self.base_url}/bigdata\"\n        self.status_url = f\"{blazegraph_base}/status\"\n        self.sparql_url = f\"{blazegraph_base}/namespace/kb/sparql\"\n        self.dataloader_url = f\"{blazegraph_base}/dataloader\"\n        self.docker_run_command = f\"docker run -d --name {self.container_name} -p {self.port}:8080 {self.image}\"\n</code></pre>"},{"location":"#omnigraph.jena","title":"<code>jena</code>","text":"<p>Created on 2025-05-28</p> <p>Apache Jena SPARQL support</p> <p>@author: wf</p>"},{"location":"#omnigraph.jena.Jena","title":"<code>Jena</code>","text":"<p>               Bases: <code>SparqlServer</code></p> <p>Dockerized Apache Jena Fuseki SPARQL server</p> Source code in <code>omnigraph/jena.py</code> <pre><code>class Jena(SparqlServer):\n    \"\"\"\n    Dockerized Apache Jena Fuseki SPARQL server\n    \"\"\"\n\n    def __init__(\n        self,\n        config: ServerConfig,\n        log: Log = None,\n        shell: Shell = None,\n        debug: bool = False,\n    ):\n        \"\"\"\n        Initialize the Jena Fuseki manager.\n\n        Args:\n            config: Jena server configuration\n            log: Log instance for logging\n            shell: Shell instance for Docker commands\n            debug: Enable debug output\n        \"\"\"\n        super().__init__(config=config, log=log, shell=shell, debug=debug)\n        self.dataset = getattr(config, \"dataset\", \"ds\")\n        self.update_url = f\"{self.config.base_url}/{self.dataset}/update\"\n        self.upload_url = f\"{self.config.base_url}/{self.dataset}/data\"\n\n    def status(self) -&gt; dict:\n        \"\"\"\n        Get Jena Fuseki status information.\n\n        Returns:\n            Dictionary with status information, empty dict if error\n        \"\"\"\n        result = self._make_request(\"GET\", self.config.status_url, timeout=2)\n\n        if result[\"success\"]:\n            status = {\"status\": \"ready\"}\n        else:\n            error_msg = result.get(\"error\", f\"status_code: {result['status_code']}\")\n            status = {\"status\": f\"error: {error_msg}\"}\n        return status\n</code></pre>"},{"location":"#omnigraph.jena.Jena.__init__","title":"<code>__init__(config, log=None, shell=None, debug=False)</code>","text":"<p>Initialize the Jena Fuseki manager.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ServerConfig</code> <p>Jena server configuration</p> required <code>log</code> <code>Log</code> <p>Log instance for logging</p> <code>None</code> <code>shell</code> <code>Shell</code> <p>Shell instance for Docker commands</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug output</p> <code>False</code> Source code in <code>omnigraph/jena.py</code> <pre><code>def __init__(\n    self,\n    config: ServerConfig,\n    log: Log = None,\n    shell: Shell = None,\n    debug: bool = False,\n):\n    \"\"\"\n    Initialize the Jena Fuseki manager.\n\n    Args:\n        config: Jena server configuration\n        log: Log instance for logging\n        shell: Shell instance for Docker commands\n        debug: Enable debug output\n    \"\"\"\n    super().__init__(config=config, log=log, shell=shell, debug=debug)\n    self.dataset = getattr(config, \"dataset\", \"ds\")\n    self.update_url = f\"{self.config.base_url}/{self.dataset}/update\"\n    self.upload_url = f\"{self.config.base_url}/{self.dataset}/data\"\n</code></pre>"},{"location":"#omnigraph.jena.Jena.status","title":"<code>status()</code>","text":"<p>Get Jena Fuseki status information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with status information, empty dict if error</p> Source code in <code>omnigraph/jena.py</code> <pre><code>def status(self) -&gt; dict:\n    \"\"\"\n    Get Jena Fuseki status information.\n\n    Returns:\n        Dictionary with status information, empty dict if error\n    \"\"\"\n    result = self._make_request(\"GET\", self.config.status_url, timeout=2)\n\n    if result[\"success\"]:\n        status = {\"status\": \"ready\"}\n    else:\n        error_msg = result.get(\"error\", f\"status_code: {result['status_code']}\")\n        status = {\"status\": f\"error: {error_msg}\"}\n    return status\n</code></pre>"},{"location":"#omnigraph.jena.JenaConfig","title":"<code>JenaConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ServerConfig</code></p> <p>Jena Fuseki configuration</p> Source code in <code>omnigraph/jena.py</code> <pre><code>@dataclass\nclass JenaConfig(ServerConfig):\n    \"\"\"\n    Jena Fuseki configuration\n    \"\"\"\n\n    dataset: str = \"ds\"\n\n    def __post_init__(self):\n        super().__post_init__()\n        self.status_url = f\"{self.base_url}/$/ping\"\n        self.sparql_url = f\"{self.base_url}/{self.dataset}/sparql\"\n        self.update_url = f\"{self.base_url}/{self.dataset}/update\"\n        self.upload_url = f\"{self.base_url}/{self.dataset}/data\"\n        self.docker_run_command = (\n            f\"docker run -d --name {self.container_name} -p {self.port}:3030 -e ADMIN_PASSWORD=admin {self.image}\"\n        )\n</code></pre>"},{"location":"#omnigraph.jena.__init__","title":"<code>__init__(self, config, log=None, shell=None, debug=False)</code>","text":"<p>Initialize the Jena Fuseki manager.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ServerConfig</code> <p>Jena server configuration</p> required <code>log</code> <code>Log</code> <p>Log instance for logging</p> <code>None</code> <code>shell</code> <code>Shell</code> <p>Shell instance for Docker commands</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug output</p> <code>False</code> Source code in <code>omnigraph/jena.py</code> <pre><code>def __init__(\n    self,\n    config: ServerConfig,\n    log: Log = None,\n    shell: Shell = None,\n    debug: bool = False,\n):\n    \"\"\"\n    Initialize the Jena Fuseki manager.\n\n    Args:\n        config: Jena server configuration\n        log: Log instance for logging\n        shell: Shell instance for Docker commands\n        debug: Enable debug output\n    \"\"\"\n    super().__init__(config=config, log=log, shell=shell, debug=debug)\n    self.dataset = getattr(config, \"dataset\", \"ds\")\n    self.update_url = f\"{self.config.base_url}/{self.dataset}/update\"\n    self.upload_url = f\"{self.config.base_url}/{self.dataset}/data\"\n</code></pre>"},{"location":"#omnigraph.ominigraph_paths","title":"<code>ominigraph_paths</code>","text":"<p>Created on 27.05.2025</p> <p>@author: wf</p>"},{"location":"#omnigraph.ominigraph_paths.OmnigraphPaths","title":"<code>OmnigraphPaths</code>","text":"<p>Omnigraph Default Paths</p> Source code in <code>omnigraph/ominigraph_paths.py</code> <pre><code>class OmnigraphPaths:\n    \"\"\"\n    Omnigraph Default Paths\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.home_dir = Path.home()\n        self.omnigraph_dir = self.home_dir / \".omnigraph\"\n        self.omnigraph_dir.mkdir(exist_ok=True)\n        self.examples_dir = (Path(__file__).parent / \"resources\" / \"examples\").resolve()\n</code></pre>"},{"location":"#omnigraph.ominigraph_paths.OmnigraphPaths.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>omnigraph/ominigraph_paths.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.home_dir = Path.home()\n    self.omnigraph_dir = self.home_dir / \".omnigraph\"\n    self.omnigraph_dir.mkdir(exist_ok=True)\n    self.examples_dir = (Path(__file__).parent / \"resources\" / \"examples\").resolve()\n</code></pre>"},{"location":"#omnigraph.omnigraph_cmd","title":"<code>omnigraph_cmd</code>","text":"<p>Created on 2025-05-28</p> <p>@author: wf</p>"},{"location":"#omnigraph.omnigraph_cmd.OmnigraphCmd","title":"<code>OmnigraphCmd</code>","text":"<p>Command line interface for omnigraph.</p> Source code in <code>omnigraph/omnigraph_cmd.py</code> <pre><code>class OmnigraphCmd:\n    \"\"\"\n    Command line interface for omnigraph.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize command line interface.\n        \"\"\"\n        self.ogp = OmnigraphPaths()\n        self.default_yaml_path = self.ogp.examples_dir / \"servers.yaml\"\n        self.version = Version()\n        self.program_version_message = f\"{self.version.name} {self.version.version}\"\n        self.parser = self.getArgParser()\n\n    def getArgParser(self, description: str = None, version_msg=None) -&gt; ArgumentParser:\n        \"\"\"\n        Setup command line argument parser\n\n        Args:\n            description(str): the description\n            version_msg(str): the version message\n\n        Returns:\n            ArgumentParser: the argument parser\n        \"\"\"\n        if description is None:\n            description = self.version.description\n        if version_msg is None:\n            version_msg = self.program_version_message\n\n        parser = ArgumentParser(\n            description=description, formatter_class=RawDescriptionHelpFormatter\n        )\n        parser.add_argument(\n            \"-a\",\n            \"--about\",\n            help=\"show about info [default: %(default)s]\",\n            action=\"store_true\",\n        )\n        parser.add_argument(\n            \"-c\",\"--config\",\n            type=str,\n            default=str(self.default_yaml_path),\n            help=\"Path to server configuration YAML file [default: %(default)s]\"\n        )\n        parser.add_argument(\n            \"--cmd\",\n            nargs=\"+\",\n            help=\"commands to execute on servers: start, stop, status\"\n        )\n        parser.add_argument(\n            \"-d\",\n            \"--debug\",\n            action=\"store_true\",\n            help=\"show debug info [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-l\",\n            \"--list-servers\",\n            action=\"store_true\",\n            help=\"List available servers [default: %(default)s]\"\n        )\n        parser.add_argument(\n            \"-s\",\"--servers\",\n            nargs=\"+\",\n            default=[\"blazegraph\"],\n            help=\"servers: servers to work with - all is an alias for all servers [default: %(default)s]\"\n        )\n        parser.add_argument(\n            \"-v\",\n            \"--verbose\",\n            action=\"store_true\",\n            help=\"show verbose output [default: %(default)s]\",\n        )\n        parser.add_argument(\"-V\", \"--version\", action=\"version\", version=version_msg)\n        return parser\n\n    def getServers(self) -&gt; Dict[str, SparqlServer]:\n        \"\"\"\n        Get the servers to work with.\n\n        Returns:\n            Dictionary of active servers\n        \"\"\"\n        servers = {}\n        server_names = self.args.servers\n        if \"all\" in server_names:\n            server_names = list(self.all_servers.keys())\n        for server_name in server_names:\n            server = self.all_servers.get(server_name)\n            if server:\n                servers[server_name] = server\n        return servers\n\n    def run_cmds(self, server: SparqlServer, cmds: List[str]) -&gt; bool:\n        \"\"\"\n        Run commands on a server.\n\n        Args:\n            server: Server instance\n            cmds: List of commands to execute\n\n        Returns:\n            True if any commands were handled\n        \"\"\"\n        handled=False\n        s_cmds = {\n            \"start\": ServerCmd(title=f\"start {server.name}\", func=server.start),\n            \"stop\": ServerCmd(title=f\"stop {server.name}\", func=server.stop),\n            \"status\": ServerCmd(title=f\"status {server.name}\", func=server.status)\n        }\n        if cmds:\n            for cmd in cmds:\n                s_cmd=s_cmds.get(cmd)\n                if s_cmd:\n                    s_cmd.run()\n                    handled=True\n                else:\n                    print(f\"unsupported command {cmd}\")\n        return handled\n\n\n    def handle_args(self,args:Namespace) -&gt; bool:\n        \"\"\"\n        Handle command line arguments.\n\n        Returns:\n            bool: True if arguments were handled, False otherwise\n            args: Namespace\n        \"\"\"\n        self.args=args\n        handled = False\n        self.all_servers={}\n        if Path(self.args.config).exists():\n            env=ServerEnv(debug=args.debug,verbose=args.verbose)\n            omni_server=OmniServer(env=env)\n            self.all_servers = omni_server.servers(args.config)\n        else:\n            print(f\"Config file not found: {args.config}\")\n\n        if args.about:\n            print(self.program_version_message)\n            print(f\"{len(self.servers)} servers configured\")\n            print(f\"see {self.version.doc_url}\")\n            webbrowser.open(self.version.doc_url)\n            handled = True\n\n        if self.args.list_servers:\n            print(\"Available servers:\")\n            for name, server in self.servers.items():\n                print(f\"  {name}: {server.config.server}\")\n            handled = True\n\n        self.servers=self.getServers()\n        for server in self.servers.values():\n            handled=handled or self.run_cmds(server,cmds=args.cmd)\n\n        return handled\n</code></pre>"},{"location":"#omnigraph.omnigraph_cmd.OmnigraphCmd.__init__","title":"<code>__init__()</code>","text":"<p>Initialize command line interface.</p> Source code in <code>omnigraph/omnigraph_cmd.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize command line interface.\n    \"\"\"\n    self.ogp = OmnigraphPaths()\n    self.default_yaml_path = self.ogp.examples_dir / \"servers.yaml\"\n    self.version = Version()\n    self.program_version_message = f\"{self.version.name} {self.version.version}\"\n    self.parser = self.getArgParser()\n</code></pre>"},{"location":"#omnigraph.omnigraph_cmd.OmnigraphCmd.getArgParser","title":"<code>getArgParser(description=None, version_msg=None)</code>","text":"<p>Setup command line argument parser</p> <p>Parameters:</p> Name Type Description Default <code>description(str)</code> <p>the description</p> required <code>version_msg(str)</code> <p>the version message</p> required <p>Returns:</p> Name Type Description <code>ArgumentParser</code> <code>ArgumentParser</code> <p>the argument parser</p> Source code in <code>omnigraph/omnigraph_cmd.py</code> <pre><code>def getArgParser(self, description: str = None, version_msg=None) -&gt; ArgumentParser:\n    \"\"\"\n    Setup command line argument parser\n\n    Args:\n        description(str): the description\n        version_msg(str): the version message\n\n    Returns:\n        ArgumentParser: the argument parser\n    \"\"\"\n    if description is None:\n        description = self.version.description\n    if version_msg is None:\n        version_msg = self.program_version_message\n\n    parser = ArgumentParser(\n        description=description, formatter_class=RawDescriptionHelpFormatter\n    )\n    parser.add_argument(\n        \"-a\",\n        \"--about\",\n        help=\"show about info [default: %(default)s]\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"-c\",\"--config\",\n        type=str,\n        default=str(self.default_yaml_path),\n        help=\"Path to server configuration YAML file [default: %(default)s]\"\n    )\n    parser.add_argument(\n        \"--cmd\",\n        nargs=\"+\",\n        help=\"commands to execute on servers: start, stop, status\"\n    )\n    parser.add_argument(\n        \"-d\",\n        \"--debug\",\n        action=\"store_true\",\n        help=\"show debug info [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-l\",\n        \"--list-servers\",\n        action=\"store_true\",\n        help=\"List available servers [default: %(default)s]\"\n    )\n    parser.add_argument(\n        \"-s\",\"--servers\",\n        nargs=\"+\",\n        default=[\"blazegraph\"],\n        help=\"servers: servers to work with - all is an alias for all servers [default: %(default)s]\"\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"show verbose output [default: %(default)s]\",\n    )\n    parser.add_argument(\"-V\", \"--version\", action=\"version\", version=version_msg)\n    return parser\n</code></pre>"},{"location":"#omnigraph.omnigraph_cmd.OmnigraphCmd.getServers","title":"<code>getServers()</code>","text":"<p>Get the servers to work with.</p> <p>Returns:</p> Type Description <code>Dict[str, SparqlServer]</code> <p>Dictionary of active servers</p> Source code in <code>omnigraph/omnigraph_cmd.py</code> <pre><code>def getServers(self) -&gt; Dict[str, SparqlServer]:\n    \"\"\"\n    Get the servers to work with.\n\n    Returns:\n        Dictionary of active servers\n    \"\"\"\n    servers = {}\n    server_names = self.args.servers\n    if \"all\" in server_names:\n        server_names = list(self.all_servers.keys())\n    for server_name in server_names:\n        server = self.all_servers.get(server_name)\n        if server:\n            servers[server_name] = server\n    return servers\n</code></pre>"},{"location":"#omnigraph.omnigraph_cmd.OmnigraphCmd.handle_args","title":"<code>handle_args(args)</code>","text":"<p>Handle command line arguments.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if arguments were handled, False otherwise</p> <code>args</code> <code>bool</code> <p>Namespace</p> Source code in <code>omnigraph/omnigraph_cmd.py</code> <pre><code>def handle_args(self,args:Namespace) -&gt; bool:\n    \"\"\"\n    Handle command line arguments.\n\n    Returns:\n        bool: True if arguments were handled, False otherwise\n        args: Namespace\n    \"\"\"\n    self.args=args\n    handled = False\n    self.all_servers={}\n    if Path(self.args.config).exists():\n        env=ServerEnv(debug=args.debug,verbose=args.verbose)\n        omni_server=OmniServer(env=env)\n        self.all_servers = omni_server.servers(args.config)\n    else:\n        print(f\"Config file not found: {args.config}\")\n\n    if args.about:\n        print(self.program_version_message)\n        print(f\"{len(self.servers)} servers configured\")\n        print(f\"see {self.version.doc_url}\")\n        webbrowser.open(self.version.doc_url)\n        handled = True\n\n    if self.args.list_servers:\n        print(\"Available servers:\")\n        for name, server in self.servers.items():\n            print(f\"  {name}: {server.config.server}\")\n        handled = True\n\n    self.servers=self.getServers()\n    for server in self.servers.values():\n        handled=handled or self.run_cmds(server,cmds=args.cmd)\n\n    return handled\n</code></pre>"},{"location":"#omnigraph.omnigraph_cmd.OmnigraphCmd.run_cmds","title":"<code>run_cmds(server, cmds)</code>","text":"<p>Run commands on a server.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>SparqlServer</code> <p>Server instance</p> required <code>cmds</code> <code>List[str]</code> <p>List of commands to execute</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if any commands were handled</p> Source code in <code>omnigraph/omnigraph_cmd.py</code> <pre><code>def run_cmds(self, server: SparqlServer, cmds: List[str]) -&gt; bool:\n    \"\"\"\n    Run commands on a server.\n\n    Args:\n        server: Server instance\n        cmds: List of commands to execute\n\n    Returns:\n        True if any commands were handled\n    \"\"\"\n    handled=False\n    s_cmds = {\n        \"start\": ServerCmd(title=f\"start {server.name}\", func=server.start),\n        \"stop\": ServerCmd(title=f\"stop {server.name}\", func=server.stop),\n        \"status\": ServerCmd(title=f\"status {server.name}\", func=server.status)\n    }\n    if cmds:\n        for cmd in cmds:\n            s_cmd=s_cmds.get(cmd)\n            if s_cmd:\n                s_cmd.run()\n                handled=True\n            else:\n                print(f\"unsupported command {cmd}\")\n    return handled\n</code></pre>"},{"location":"#omnigraph.omnigraph_cmd.ServerCmd","title":"<code>ServerCmd</code>  <code>dataclass</code>","text":"<p>Command wrapper for server operations.</p> Source code in <code>omnigraph/omnigraph_cmd.py</code> <pre><code>@dataclass\nclass ServerCmd:\n    \"\"\"\n    Command wrapper for server operations.\n    \"\"\"\n\n    def __init__(self, title: str, func: Callable):\n        \"\"\"\n        Initialize server command.\n\n        Args:\n            title: Description of the command\n            func: Function to execute\n        \"\"\"\n        self.title = title\n        self.func = func\n\n    def run(self, verbose: bool = True) -&gt; any:\n        \"\"\"\n        Execute the server command.\n\n        Args:\n            verbose: Whether to print result\n\n        Returns:\n            Result from function execution\n        \"\"\"\n        result = self.func()\n        if verbose:\n            print(f\"{self.title}: {result}\")\n        return result\n</code></pre>"},{"location":"#omnigraph.omnigraph_cmd.ServerCmd.__init__","title":"<code>__init__(title, func)</code>","text":"<p>Initialize server command.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Description of the command</p> required <code>func</code> <code>Callable</code> <p>Function to execute</p> required Source code in <code>omnigraph/omnigraph_cmd.py</code> <pre><code>def __init__(self, title: str, func: Callable):\n    \"\"\"\n    Initialize server command.\n\n    Args:\n        title: Description of the command\n        func: Function to execute\n    \"\"\"\n    self.title = title\n    self.func = func\n</code></pre>"},{"location":"#omnigraph.omnigraph_cmd.ServerCmd.run","title":"<code>run(verbose=True)</code>","text":"<p>Execute the server command.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Whether to print result</p> <code>True</code> <p>Returns:</p> Type Description <code>any</code> <p>Result from function execution</p> Source code in <code>omnigraph/omnigraph_cmd.py</code> <pre><code>def run(self, verbose: bool = True) -&gt; any:\n    \"\"\"\n    Execute the server command.\n\n    Args:\n        verbose: Whether to print result\n\n    Returns:\n        Result from function execution\n    \"\"\"\n    result = self.func()\n    if verbose:\n        print(f\"{self.title}: {result}\")\n    return result\n</code></pre>"},{"location":"#omnigraph.omnigraph_cmd.main","title":"<code>main()</code>","text":"<p>Main entry point for command line interface.</p> Source code in <code>omnigraph/omnigraph_cmd.py</code> <pre><code>def main():\n    \"\"\"\n    Main entry point for command line interface.\n    \"\"\"\n    cmd = OmnigraphCmd()\n    args = cmd.parser.parse_args()\n    cmd.handle_args(args)\n</code></pre>"},{"location":"#omnigraph.omniserver","title":"<code>omniserver</code>","text":"<p>Created on 2025-05-28</p> <p>@author: wf</p>"},{"location":"#omnigraph.omniserver.OmniServer","title":"<code>OmniServer</code>","text":"<p>Factory class for creating and managing SPARQL server instances.</p> Source code in <code>omnigraph/omniserver.py</code> <pre><code>class OmniServer:\n    \"\"\"\n    Factory class for creating and managing SPARQL server instances.\n    \"\"\"\n\n    def __init__(self,env:ServerEnv):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.env=env\n\n    def server4Config(self, config: ServerConfig) -&gt; SparqlServer:\n        \"\"\"\n        Create a SparqlServer instance based on server type in config.\n\n        Args:\n            config: ServerConfig with server type and settings\n\n        Returns:\n            SparqlServer instance of appropriate type\n        \"\"\"\n        server_instance = None\n        config_dict = asdict(config)\n\n        if config.server == \"blazegraph\":\n            blazegraph_config = BlazegraphConfig(**config_dict)\n            server_instance = Blazegraph(config=blazegraph_config,env=self.env)\n        elif config.server == \"qlever\":\n            qlever_config = QLeverConfig(**config_dict)\n            server_instance = QLever(config=qlever_config,env=self.env)\n        elif config.server == \"jena\":\n            jena_config = JenaConfig(**config_dict)\n            server_instance = Jena(config=jena_config,env=self.env)\n\n        return server_instance\n\n    def servers(self, yaml_path: Path) -&gt; Dict[str, SparqlServer]:\n        \"\"\"\n        Load active servers from YAML configuration.\n\n        Args:\n            yaml_path: Path to YAML configuration file\n\n        Returns:\n            Dictionary mapping server names to SparqlServer instances\n        \"\"\"\n        server_configs = ServerConfigs.ofYaml(yaml_path)\n        servers_dict = {}\n\n        for server_name, config in server_configs.servers.items():\n            if config.active:\n                server_instance = self.server4Config(config)\n                if server_instance:\n                    servers_dict[server_name] = server_instance\n\n        return servers_dict\n</code></pre>"},{"location":"#omnigraph.omniserver.OmniServer.__init__","title":"<code>__init__(env)</code>","text":"<p>constructor</p> Source code in <code>omnigraph/omniserver.py</code> <pre><code>def __init__(self,env:ServerEnv):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.env=env\n</code></pre>"},{"location":"#omnigraph.omniserver.OmniServer.server4Config","title":"<code>server4Config(config)</code>","text":"<p>Create a SparqlServer instance based on server type in config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ServerConfig</code> <p>ServerConfig with server type and settings</p> required <p>Returns:</p> Type Description <code>SparqlServer</code> <p>SparqlServer instance of appropriate type</p> Source code in <code>omnigraph/omniserver.py</code> <pre><code>def server4Config(self, config: ServerConfig) -&gt; SparqlServer:\n    \"\"\"\n    Create a SparqlServer instance based on server type in config.\n\n    Args:\n        config: ServerConfig with server type and settings\n\n    Returns:\n        SparqlServer instance of appropriate type\n    \"\"\"\n    server_instance = None\n    config_dict = asdict(config)\n\n    if config.server == \"blazegraph\":\n        blazegraph_config = BlazegraphConfig(**config_dict)\n        server_instance = Blazegraph(config=blazegraph_config,env=self.env)\n    elif config.server == \"qlever\":\n        qlever_config = QLeverConfig(**config_dict)\n        server_instance = QLever(config=qlever_config,env=self.env)\n    elif config.server == \"jena\":\n        jena_config = JenaConfig(**config_dict)\n        server_instance = Jena(config=jena_config,env=self.env)\n\n    return server_instance\n</code></pre>"},{"location":"#omnigraph.omniserver.OmniServer.servers","title":"<code>servers(yaml_path)</code>","text":"<p>Load active servers from YAML configuration.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_path</code> <code>Path</code> <p>Path to YAML configuration file</p> required <p>Returns:</p> Type Description <code>Dict[str, SparqlServer]</code> <p>Dictionary mapping server names to SparqlServer instances</p> Source code in <code>omnigraph/omniserver.py</code> <pre><code>def servers(self, yaml_path: Path) -&gt; Dict[str, SparqlServer]:\n    \"\"\"\n    Load active servers from YAML configuration.\n\n    Args:\n        yaml_path: Path to YAML configuration file\n\n    Returns:\n        Dictionary mapping server names to SparqlServer instances\n    \"\"\"\n    server_configs = ServerConfigs.ofYaml(yaml_path)\n    servers_dict = {}\n\n    for server_name, config in server_configs.servers.items():\n        if config.active:\n            server_instance = self.server4Config(config)\n            if server_instance:\n                servers_dict[server_name] = server_instance\n\n    return servers_dict\n</code></pre>"},{"location":"#omnigraph.persistent_log","title":"<code>persistent_log</code>","text":"<p>This is redundant copy to avoid dependeny hell the original is at https://github.com/WolfgangFahl/nicegui_widgets/blob/main/ngwidgets/persistent_log.py</p> <p>Created on 2024-10-04</p> <p>@author: wf</p>"},{"location":"#omnigraph.persistent_log.Log","title":"<code>Log</code>","text":"<p>Wrapper for persistent logging.</p> Source code in <code>omnigraph/persistent_log.py</code> <pre><code>@lod_storable\nclass Log:\n    \"\"\"\n    Wrapper for persistent logging.\n    \"\"\"\n\n    entries: List[LogEntry] = field(default_factory=list)\n\n    def color_msg(self, color, msg):\n        \"\"\"Display a colored message\"\"\"\n        print(f\"{color}{msg}{END_COLOR}\")\n\n    def __post_init__(self):\n        \"\"\"\n        Initializes the log with level mappings and updates the level counts.\n        \"\"\"\n        self.do_log = True\n        self.do_print = False\n        self.levels = {\"\u274c\": logging.ERROR, \"\u26a0\ufe0f\": logging.WARNING, \"\u2705\": logging.INFO}\n        self.level_names = {\n            logging.ERROR: \"error\",\n            logging.WARNING: \"warn\",\n            logging.INFO: \"info\",\n        }\n        self.update_level_counts()\n\n    def clear(self):\n        \"\"\"\n        Clears all log entries.\n        \"\"\"\n        self.entries = []\n        self.update_level_counts()\n\n    def update_level_counts(self):\n        \"\"\"\n        Updates the counts for each log level based on the existing entries.\n        \"\"\"\n        self.level_counts = {\"error\": Counter(), \"warn\": Counter(), \"info\": Counter()}\n        for entry in self.entries:\n            counter = self.get_counter(entry.level_name)\n            if counter is not None:\n                counter[entry.kind] += 1\n\n    def get_counter(self, level: str) -&gt; Counter:\n        \"\"\"\n        Returns the counter for the specified log level.\n        \"\"\"\n        return self.level_counts.get(level)\n\n    def get_level_summary(self, level: str, limit: int = 7) -&gt; Tuple[int, str]:\n        \"\"\"\n        Get a summary of the most common counts for the specified log level.\n\n        Args:\n            level (str): The log level name ('error', 'warn', 'info').\n            limit (int): The maximum number of most common entries to include in the summary (default is 7).\n\n        Returns:\n            Tuple[int, str]: A tuple containing the count of log entries and a summary message.\n        \"\"\"\n        counter = self.get_counter(level)\n        if counter:\n            count = sum(counter.values())\n            most_common_entries = dict(counter.most_common(limit))  # Get the top 'limit' entries\n            summary_msg = f\"{level.capitalize()} entries: {most_common_entries}\"\n            return count, summary_msg\n        return 0, f\"No entries found for level: {level}\"\n\n    def log(self, icon: str, kind: str, msg: str):\n        \"\"\"\n        Log a message with the specified icon and kind.\n\n        Args:\n            icon (str): The icon representing the log level ('\u274c', '\u26a0\ufe0f', '\u2705').\n            kind (str): The category or type of the log message.\n            msg (str): The log message to record.\n        \"\"\"\n        level = self.levels.get(icon, logging.INFO)\n        level_name = self.level_names[level]\n        icon_msg = f\"{icon}:{msg}\"\n        log_entry = LogEntry(msg=icon_msg, level_name=level_name, kind=kind)\n        self.entries.append(log_entry)\n\n        # Update level counts\n        self.level_counts[level_name][kind] += 1\n\n        if self.do_log:\n            logging.log(level, icon_msg)\n        if self.do_print:\n            print(icon_msg)\n</code></pre>"},{"location":"#omnigraph.persistent_log.Log.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initializes the log with level mappings and updates the level counts.</p> Source code in <code>omnigraph/persistent_log.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Initializes the log with level mappings and updates the level counts.\n    \"\"\"\n    self.do_log = True\n    self.do_print = False\n    self.levels = {\"\u274c\": logging.ERROR, \"\u26a0\ufe0f\": logging.WARNING, \"\u2705\": logging.INFO}\n    self.level_names = {\n        logging.ERROR: \"error\",\n        logging.WARNING: \"warn\",\n        logging.INFO: \"info\",\n    }\n    self.update_level_counts()\n</code></pre>"},{"location":"#omnigraph.persistent_log.Log.clear","title":"<code>clear()</code>","text":"<p>Clears all log entries.</p> Source code in <code>omnigraph/persistent_log.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Clears all log entries.\n    \"\"\"\n    self.entries = []\n    self.update_level_counts()\n</code></pre>"},{"location":"#omnigraph.persistent_log.Log.color_msg","title":"<code>color_msg(color, msg)</code>","text":"<p>Display a colored message</p> Source code in <code>omnigraph/persistent_log.py</code> <pre><code>def color_msg(self, color, msg):\n    \"\"\"Display a colored message\"\"\"\n    print(f\"{color}{msg}{END_COLOR}\")\n</code></pre>"},{"location":"#omnigraph.persistent_log.Log.get_counter","title":"<code>get_counter(level)</code>","text":"<p>Returns the counter for the specified log level.</p> Source code in <code>omnigraph/persistent_log.py</code> <pre><code>def get_counter(self, level: str) -&gt; Counter:\n    \"\"\"\n    Returns the counter for the specified log level.\n    \"\"\"\n    return self.level_counts.get(level)\n</code></pre>"},{"location":"#omnigraph.persistent_log.Log.get_level_summary","title":"<code>get_level_summary(level, limit=7)</code>","text":"<p>Get a summary of the most common counts for the specified log level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>The log level name ('error', 'warn', 'info').</p> required <code>limit</code> <code>int</code> <p>The maximum number of most common entries to include in the summary (default is 7).</p> <code>7</code> <p>Returns:</p> Type Description <code>Tuple[int, str]</code> <p>Tuple[int, str]: A tuple containing the count of log entries and a summary message.</p> Source code in <code>omnigraph/persistent_log.py</code> <pre><code>def get_level_summary(self, level: str, limit: int = 7) -&gt; Tuple[int, str]:\n    \"\"\"\n    Get a summary of the most common counts for the specified log level.\n\n    Args:\n        level (str): The log level name ('error', 'warn', 'info').\n        limit (int): The maximum number of most common entries to include in the summary (default is 7).\n\n    Returns:\n        Tuple[int, str]: A tuple containing the count of log entries and a summary message.\n    \"\"\"\n    counter = self.get_counter(level)\n    if counter:\n        count = sum(counter.values())\n        most_common_entries = dict(counter.most_common(limit))  # Get the top 'limit' entries\n        summary_msg = f\"{level.capitalize()} entries: {most_common_entries}\"\n        return count, summary_msg\n    return 0, f\"No entries found for level: {level}\"\n</code></pre>"},{"location":"#omnigraph.persistent_log.Log.log","title":"<code>log(icon, kind, msg)</code>","text":"<p>Log a message with the specified icon and kind.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>str</code> <p>The icon representing the log level ('\u274c', '\u26a0\ufe0f', '\u2705').</p> required <code>kind</code> <code>str</code> <p>The category or type of the log message.</p> required <code>msg</code> <code>str</code> <p>The log message to record.</p> required Source code in <code>omnigraph/persistent_log.py</code> <pre><code>def log(self, icon: str, kind: str, msg: str):\n    \"\"\"\n    Log a message with the specified icon and kind.\n\n    Args:\n        icon (str): The icon representing the log level ('\u274c', '\u26a0\ufe0f', '\u2705').\n        kind (str): The category or type of the log message.\n        msg (str): The log message to record.\n    \"\"\"\n    level = self.levels.get(icon, logging.INFO)\n    level_name = self.level_names[level]\n    icon_msg = f\"{icon}:{msg}\"\n    log_entry = LogEntry(msg=icon_msg, level_name=level_name, kind=kind)\n    self.entries.append(log_entry)\n\n    # Update level counts\n    self.level_counts[level_name][kind] += 1\n\n    if self.do_log:\n        logging.log(level, icon_msg)\n    if self.do_print:\n        print(icon_msg)\n</code></pre>"},{"location":"#omnigraph.persistent_log.Log.update_level_counts","title":"<code>update_level_counts()</code>","text":"<p>Updates the counts for each log level based on the existing entries.</p> Source code in <code>omnigraph/persistent_log.py</code> <pre><code>def update_level_counts(self):\n    \"\"\"\n    Updates the counts for each log level based on the existing entries.\n    \"\"\"\n    self.level_counts = {\"error\": Counter(), \"warn\": Counter(), \"info\": Counter()}\n    for entry in self.entries:\n        counter = self.get_counter(entry.level_name)\n        if counter is not None:\n            counter[entry.kind] += 1\n</code></pre>"},{"location":"#omnigraph.persistent_log.LogEntry","title":"<code>LogEntry</code>","text":"<p>Represents a log entry with a message, kind, and log level name.</p> Source code in <code>omnigraph/persistent_log.py</code> <pre><code>@lod_storable\nclass LogEntry:\n    \"\"\"\n    Represents a log entry with a message, kind, and log level name.\n    \"\"\"\n\n    msg: str\n    kind: str\n    level_name: str\n    timestamp: Optional[str] = None\n\n    def __post_init__(self):\n        if self.timestamp is None:\n            self.timestamp = datetime.now().isoformat()\n</code></pre>"},{"location":"#omnigraph.qlever","title":"<code>qlever</code>","text":"<p>Created on 2025-05-28</p> <p>@author: wf</p>"},{"location":"#omnigraph.qlever.QLever","title":"<code>QLever</code>","text":"<p>               Bases: <code>SparqlServer</code></p> <p>Dockerized QLever SPARQL server</p> Source code in <code>omnigraph/qlever.py</code> <pre><code>class QLever(SparqlServer):\n    \"\"\"\n    Dockerized QLever SPARQL server\n    \"\"\"\n\n    def __init__(\n        self,\n        container_name: str = \"qlever\",\n        image: str = \"adfreiburg/qlever\",\n        data_dir: str = None,\n        dataset: str = \"olympics\",\n        port: int = 7001,\n        log: Log = None,\n        shell: Shell = None,\n        debug: bool = False,\n    ):\n        \"\"\"\n        Initialize the QLever manager.\n\n        Args:\n            container_name: Docker container name\n            image: Docker image to use\n            port: Port for QLever web interface\n            data_dir: where to keep the data\n            dataset(str): a default dataset to be loaded\n            log: Log instance for logging\n            shell: Shell instance for Docker commands\n            debug: Enable debug output\n        \"\"\"\n        if not data_dir:\n            raise ValueError(\"Data directory needs to be specified\")\n        self.data_dir = data_dir\n        self.dataset = dataset\n        super().__init__(container_name, image, port, log, shell, debug)\n\n    def start(self, show_progress: bool = True) -&gt; bool:\n        \"\"\"\n        Start QLever using proper workflow.\n        \"\"\"\n        # Use base class start to get container running\n        started = super().start(show_progress=show_progress)\n        if started and self.dataset:\n            # Run QLever setup workflow\n            setup_cmd = f\"docker exec {self.container_name} qlever setup-config {self.dataset}\"\n            self._run_shell_command(setup_cmd)\n\n            get_data_cmd = f\"docker exec {self.container_name} qlever get-data\"\n            self._run_shell_command(get_data_cmd)\n\n            index_cmd = f\"docker exec {self.container_name} qlever index\"\n            self._run_shell_command(index_cmd)\n\n            start_cmd = f\"docker exec {self.container_name} qlever start\"\n            self._run_shell_command(start_cmd)\n\n        return started\n\n    def status(self) -&gt; dict:\n        \"\"\"\n        Get QLever status information.\n\n        Returns:\n            Dictionary with status information, empty dict if error\n        \"\"\"\n        status_dict = {}\n        result = self._make_request(\"GET\", self.status_url, timeout=2)\n\n        if result[\"success\"]:\n            status_dict[\"status\"] = \"ready\"\n            try:\n                import json\n\n                status_data = json.loads(result[\"content\"])\n                status_dict.update(status_data)\n            except json.JSONDecodeError:\n                status_dict[\"raw_content\"] = result[\"content\"]\n        else:\n            if result.get(\"error\"):\n                status_dict[\"status\"] = f\"error: {result['error']}\"\n            else:\n                status_dict[\"status\"] = f\"status_code: {result['status_code']}\"\n\n        return status_dict\n\n    def load_file(self, filepath: str) -&gt; bool:\n        \"\"\"\n        Load a single RDF file into QLever.\n\n        Args:\n            filepath: Path to RDF file\n\n        Returns:\n            True if loaded successfully\n        \"\"\"\n        load_success = False\n        try:\n            with open(filepath, \"rb\") as f:\n                result = self._make_request(\n                    \"POST\",\n                    f\"{self.base_url}/api/upload\",\n                    files={\"file\": f},\n                    timeout=300,\n                )\n\n            if result[\"success\"]:\n                self.log.log(\"\u2705\", self.container_name, f\"Loaded {filepath}\")\n                load_success = True\n            else:\n                error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n                self.log.log(\"\u274c\", self.container_name, f\"Failed to load {filepath}: {error_msg}\")\n                load_success = False\n\n        except Exception as e:\n            self.log.log(\"\u274c\", self.container_name, f\"Exception loading {filepath}: {e}\")\n            load_success = False\n\n        return load_success\n\n    def load_dump_files(self, file_pattern: str = \"dump_*.ttl\", use_bulk: bool = True) -&gt; int:\n        \"\"\"\n        Load all dump files matching pattern.\n\n        Args:\n            file_pattern: Glob pattern for dump files\n            use_bulk: Use bulk loader if True, individual files if False\n\n        Returns:\n            Number of files loaded successfully\n        \"\"\"\n        files = sorted(glob.glob(file_pattern))\n        loaded_count = 0\n\n        if not files:\n            self.log.log(\n                \"\u26a0\ufe0f\",\n                self.container_name,\n                f\"No files found matching pattern: {file_pattern}\",\n            )\n            loaded_count = 0\n        else:\n            self.log.log(\"\u2705\", self.container_name, f\"Found {len(files)} files to load\")\n\n            # QLever typically loads files individually\n            loaded_count = 0\n            for filepath in tqdm(files, desc=\"Loading files\"):\n                file_result = self.load_file(filepath)\n                if file_result:\n                    loaded_count += 1\n                else:\n                    self.log.log(\"\u274c\", self.container_name, f\"Failed to load: {filepath}\")\n\n        return loaded_count\n</code></pre>"},{"location":"#omnigraph.qlever.QLever.__init__","title":"<code>__init__(container_name='qlever', image='adfreiburg/qlever', data_dir=None, dataset='olympics', port=7001, log=None, shell=None, debug=False)</code>","text":"<p>Initialize the QLever manager.</p> <p>Parameters:</p> Name Type Description Default <code>container_name</code> <code>str</code> <p>Docker container name</p> <code>'qlever'</code> <code>image</code> <code>str</code> <p>Docker image to use</p> <code>'adfreiburg/qlever'</code> <code>port</code> <code>int</code> <p>Port for QLever web interface</p> <code>7001</code> <code>data_dir</code> <code>str</code> <p>where to keep the data</p> <code>None</code> <code>dataset(str)</code> <p>a default dataset to be loaded</p> required <code>log</code> <code>Log</code> <p>Log instance for logging</p> <code>None</code> <code>shell</code> <code>Shell</code> <p>Shell instance for Docker commands</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug output</p> <code>False</code> Source code in <code>omnigraph/qlever.py</code> <pre><code>def __init__(\n    self,\n    container_name: str = \"qlever\",\n    image: str = \"adfreiburg/qlever\",\n    data_dir: str = None,\n    dataset: str = \"olympics\",\n    port: int = 7001,\n    log: Log = None,\n    shell: Shell = None,\n    debug: bool = False,\n):\n    \"\"\"\n    Initialize the QLever manager.\n\n    Args:\n        container_name: Docker container name\n        image: Docker image to use\n        port: Port for QLever web interface\n        data_dir: where to keep the data\n        dataset(str): a default dataset to be loaded\n        log: Log instance for logging\n        shell: Shell instance for Docker commands\n        debug: Enable debug output\n    \"\"\"\n    if not data_dir:\n        raise ValueError(\"Data directory needs to be specified\")\n    self.data_dir = data_dir\n    self.dataset = dataset\n    super().__init__(container_name, image, port, log, shell, debug)\n</code></pre>"},{"location":"#omnigraph.qlever.QLever.load_dump_files","title":"<code>load_dump_files(file_pattern='dump_*.ttl', use_bulk=True)</code>","text":"<p>Load all dump files matching pattern.</p> <p>Parameters:</p> Name Type Description Default <code>file_pattern</code> <code>str</code> <p>Glob pattern for dump files</p> <code>'dump_*.ttl'</code> <code>use_bulk</code> <code>bool</code> <p>Use bulk loader if True, individual files if False</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of files loaded successfully</p> Source code in <code>omnigraph/qlever.py</code> <pre><code>def load_dump_files(self, file_pattern: str = \"dump_*.ttl\", use_bulk: bool = True) -&gt; int:\n    \"\"\"\n    Load all dump files matching pattern.\n\n    Args:\n        file_pattern: Glob pattern for dump files\n        use_bulk: Use bulk loader if True, individual files if False\n\n    Returns:\n        Number of files loaded successfully\n    \"\"\"\n    files = sorted(glob.glob(file_pattern))\n    loaded_count = 0\n\n    if not files:\n        self.log.log(\n            \"\u26a0\ufe0f\",\n            self.container_name,\n            f\"No files found matching pattern: {file_pattern}\",\n        )\n        loaded_count = 0\n    else:\n        self.log.log(\"\u2705\", self.container_name, f\"Found {len(files)} files to load\")\n\n        # QLever typically loads files individually\n        loaded_count = 0\n        for filepath in tqdm(files, desc=\"Loading files\"):\n            file_result = self.load_file(filepath)\n            if file_result:\n                loaded_count += 1\n            else:\n                self.log.log(\"\u274c\", self.container_name, f\"Failed to load: {filepath}\")\n\n    return loaded_count\n</code></pre>"},{"location":"#omnigraph.qlever.QLever.load_file","title":"<code>load_file(filepath)</code>","text":"<p>Load a single RDF file into QLever.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to RDF file</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully</p> Source code in <code>omnigraph/qlever.py</code> <pre><code>def load_file(self, filepath: str) -&gt; bool:\n    \"\"\"\n    Load a single RDF file into QLever.\n\n    Args:\n        filepath: Path to RDF file\n\n    Returns:\n        True if loaded successfully\n    \"\"\"\n    load_success = False\n    try:\n        with open(filepath, \"rb\") as f:\n            result = self._make_request(\n                \"POST\",\n                f\"{self.base_url}/api/upload\",\n                files={\"file\": f},\n                timeout=300,\n            )\n\n        if result[\"success\"]:\n            self.log.log(\"\u2705\", self.container_name, f\"Loaded {filepath}\")\n            load_success = True\n        else:\n            error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n            self.log.log(\"\u274c\", self.container_name, f\"Failed to load {filepath}: {error_msg}\")\n            load_success = False\n\n    except Exception as e:\n        self.log.log(\"\u274c\", self.container_name, f\"Exception loading {filepath}: {e}\")\n        load_success = False\n\n    return load_success\n</code></pre>"},{"location":"#omnigraph.qlever.QLever.start","title":"<code>start(show_progress=True)</code>","text":"<p>Start QLever using proper workflow.</p> Source code in <code>omnigraph/qlever.py</code> <pre><code>def start(self, show_progress: bool = True) -&gt; bool:\n    \"\"\"\n    Start QLever using proper workflow.\n    \"\"\"\n    # Use base class start to get container running\n    started = super().start(show_progress=show_progress)\n    if started and self.dataset:\n        # Run QLever setup workflow\n        setup_cmd = f\"docker exec {self.container_name} qlever setup-config {self.dataset}\"\n        self._run_shell_command(setup_cmd)\n\n        get_data_cmd = f\"docker exec {self.container_name} qlever get-data\"\n        self._run_shell_command(get_data_cmd)\n\n        index_cmd = f\"docker exec {self.container_name} qlever index\"\n        self._run_shell_command(index_cmd)\n\n        start_cmd = f\"docker exec {self.container_name} qlever start\"\n        self._run_shell_command(start_cmd)\n\n    return started\n</code></pre>"},{"location":"#omnigraph.qlever.QLever.status","title":"<code>status()</code>","text":"<p>Get QLever status information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with status information, empty dict if error</p> Source code in <code>omnigraph/qlever.py</code> <pre><code>def status(self) -&gt; dict:\n    \"\"\"\n    Get QLever status information.\n\n    Returns:\n        Dictionary with status information, empty dict if error\n    \"\"\"\n    status_dict = {}\n    result = self._make_request(\"GET\", self.status_url, timeout=2)\n\n    if result[\"success\"]:\n        status_dict[\"status\"] = \"ready\"\n        try:\n            import json\n\n            status_data = json.loads(result[\"content\"])\n            status_dict.update(status_data)\n        except json.JSONDecodeError:\n            status_dict[\"raw_content\"] = result[\"content\"]\n    else:\n        if result.get(\"error\"):\n            status_dict[\"status\"] = f\"error: {result['error']}\"\n        else:\n            status_dict[\"status\"] = f\"status_code: {result['status_code']}\"\n\n    return status_dict\n</code></pre>"},{"location":"#omnigraph.shell","title":"<code>shell</code>","text":"<p>This is redundant copy to avoid dependeny hell the original is at https://github.com/WolfgangFahl/nicegui_widgets/blob/main/ngwidgets/shell.py</p> <p>Created on 2025-05-14</p> <p>@author: wf</p>"},{"location":"#omnigraph.shell.Shell","title":"<code>Shell</code>","text":"<p>Runs commands with environment from profile</p> Source code in <code>omnigraph/shell.py</code> <pre><code>class Shell:\n    \"\"\"\n    Runs commands with environment from profile\n    \"\"\"\n\n    def __init__(self, profile=None, shell_path: str = None):\n        \"\"\"\n        Initialize shell with optional profile\n\n        Args:\n            profile: Path to profile file to source e.g. ~/.zprofile\n            shell_path: the shell_path e.g. /bin/zsh\n        \"\"\"\n        self.profile = profile\n        self.shell_path = shell_path\n        if self.shell_path is None:\n            self.shell_path = os.environ.get(\"SHELL\", \"/bin/bash\")\n        self.shell_name = os.path.basename(self.shell_path)\n        if self.profile is None:\n            self.profile = self.find_profile()\n\n    def find_profile(self) -&gt; str:\n        \"\"\"\n        Find the appropriate profile file for the current shell\n\n        Searches for the profile file corresponding to the shell_name\n        in the user's home directory.\n\n        Returns:\n            str: Path to the profile file or None if not found\n        \"\"\"\n        profile = None\n        home = os.path.expanduser(\"~\")\n        # Try common profile files\n        profiles = {\"zsh\": \".zprofile\", \"bash\": \".bash_profile\", \"sh\": \".profile\"}\n        if self.shell_name in profiles:\n            profile_name = profiles[self.shell_name]\n            path = os.path.join(home, profile_name)\n            if os.path.exists(path):\n                profile = path\n        return profile\n\n    @classmethod\n    def ofArgs(cls, args):\n        \"\"\"\n        Create Shell from command line args\n\n        Args:\n            args: Arguments with optional profile\n\n        Returns:\n            Shell: Configured Shell\n        \"\"\"\n        # Use explicit profile or detect\n        profile = getattr(args, \"profile\", None)\n        shell = cls(profile=profile)\n        return shell\n\n    def run(self, cmd, text=True, debug=False, tee=False) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Run command with profile, always capturing output and optionally teeing it.\n\n        Args:\n            cmd: Command to run\n            text: Text mode for subprocess I/O\n            debug: Print the command to be run\n            tee: If True, also print output live while capturing\n\n        Returns:\n            subprocess.CompletedProcess\n        \"\"\"\n        shell_cmd = f\"source {self.profile} &amp;&amp; {cmd}\" if self.profile else cmd\n\n        if debug:\n            print(f\"Running: {shell_cmd}\")\n\n        popen_process = subprocess.Popen(\n            [self.shell_path, \"-c\", shell_cmd],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=text,\n        )\n\n        std_tee = StdTee.run(popen_process, tee=tee)\n        returncode = popen_process.wait()\n\n        process = subprocess.CompletedProcess(\n            args=popen_process.args,\n            returncode=returncode,\n            stdout=std_tee.stdout_buffer.getvalue(),\n            stderr=std_tee.stderr_buffer.getvalue(),\n        )\n\n        if process.returncode != 0:\n            if debug:\n                msg = f\"\"\"{process.args} failed:\n  returncode: {process.returncode}\n  stdout    : {process.stdout.strip()}\n  stderr    : {process.stderr.strip()}\n\"\"\"\n                print(msg, file=sys.stderr)\n            pass\n\n        return process\n\n    def proc_stats(\n        self,\n        title: str,\n        procs: Dict[Path, subprocess.CompletedProcess],\n        ignores: List[str] = [],\n    ):\n        \"\"\"\n        Show process statistics with checkmark/crossmark and success/failure summary.\n\n        Args:\n            title (str): A short title to label the output section.\n            procs (Dict[Path, subprocess.CompletedProcess]): Mapping of input files to their process results.\n            ignores (List[str], optional): List of substrings. If any is found in stderr, the error is ignored.\n        \"\"\"\n        total = len(procs)\n        failures = 0\n        print(f\"\\n{total} {title}:\")\n        for idx, (path, result) in enumerate(procs.items(), start=1):\n            stderr = result.stderr or \"\"\n            stdout = result.stdout or \"\"\n            ignored = any(ignore in stderr for ignore in ignores)\n            has_error = (stderr and not ignored) or (\"Error\" in stdout)\n            if has_error:\n                symbol = \"\u274c\"\n                failures += 1\n            else:\n                symbol = \"\u2705\"\n            print(f\"{symbol} {idx}/{total}: {path.name}\")\n        percent_ok = ((total - failures) / total) * 100 if total &gt; 0 else 0\n        print(f\"\\n\u2705 {total - failures}/{total} ({percent_ok:.1f}%), \u274c {failures}/{total} ({100 - percent_ok:.1f}%)\")\n</code></pre>"},{"location":"#omnigraph.shell.Shell.__init__","title":"<code>__init__(profile=None, shell_path=None)</code>","text":"<p>Initialize shell with optional profile</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <p>Path to profile file to source e.g. ~/.zprofile</p> <code>None</code> <code>shell_path</code> <code>str</code> <p>the shell_path e.g. /bin/zsh</p> <code>None</code> Source code in <code>omnigraph/shell.py</code> <pre><code>def __init__(self, profile=None, shell_path: str = None):\n    \"\"\"\n    Initialize shell with optional profile\n\n    Args:\n        profile: Path to profile file to source e.g. ~/.zprofile\n        shell_path: the shell_path e.g. /bin/zsh\n    \"\"\"\n    self.profile = profile\n    self.shell_path = shell_path\n    if self.shell_path is None:\n        self.shell_path = os.environ.get(\"SHELL\", \"/bin/bash\")\n    self.shell_name = os.path.basename(self.shell_path)\n    if self.profile is None:\n        self.profile = self.find_profile()\n</code></pre>"},{"location":"#omnigraph.shell.Shell.find_profile","title":"<code>find_profile()</code>","text":"<p>Find the appropriate profile file for the current shell</p> <p>Searches for the profile file corresponding to the shell_name in the user's home directory.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the profile file or None if not found</p> Source code in <code>omnigraph/shell.py</code> <pre><code>def find_profile(self) -&gt; str:\n    \"\"\"\n    Find the appropriate profile file for the current shell\n\n    Searches for the profile file corresponding to the shell_name\n    in the user's home directory.\n\n    Returns:\n        str: Path to the profile file or None if not found\n    \"\"\"\n    profile = None\n    home = os.path.expanduser(\"~\")\n    # Try common profile files\n    profiles = {\"zsh\": \".zprofile\", \"bash\": \".bash_profile\", \"sh\": \".profile\"}\n    if self.shell_name in profiles:\n        profile_name = profiles[self.shell_name]\n        path = os.path.join(home, profile_name)\n        if os.path.exists(path):\n            profile = path\n    return profile\n</code></pre>"},{"location":"#omnigraph.shell.Shell.ofArgs","title":"<code>ofArgs(args)</code>  <code>classmethod</code>","text":"<p>Create Shell from command line args</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Arguments with optional profile</p> required <p>Returns:</p> Name Type Description <code>Shell</code> <p>Configured Shell</p> Source code in <code>omnigraph/shell.py</code> <pre><code>@classmethod\ndef ofArgs(cls, args):\n    \"\"\"\n    Create Shell from command line args\n\n    Args:\n        args: Arguments with optional profile\n\n    Returns:\n        Shell: Configured Shell\n    \"\"\"\n    # Use explicit profile or detect\n    profile = getattr(args, \"profile\", None)\n    shell = cls(profile=profile)\n    return shell\n</code></pre>"},{"location":"#omnigraph.shell.Shell.proc_stats","title":"<code>proc_stats(title, procs, ignores=[])</code>","text":"<p>Show process statistics with checkmark/crossmark and success/failure summary.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>A short title to label the output section.</p> required <code>procs</code> <code>Dict[Path, CompletedProcess]</code> <p>Mapping of input files to their process results.</p> required <code>ignores</code> <code>List[str]</code> <p>List of substrings. If any is found in stderr, the error is ignored.</p> <code>[]</code> Source code in <code>omnigraph/shell.py</code> <pre><code>def proc_stats(\n    self,\n    title: str,\n    procs: Dict[Path, subprocess.CompletedProcess],\n    ignores: List[str] = [],\n):\n    \"\"\"\n    Show process statistics with checkmark/crossmark and success/failure summary.\n\n    Args:\n        title (str): A short title to label the output section.\n        procs (Dict[Path, subprocess.CompletedProcess]): Mapping of input files to their process results.\n        ignores (List[str], optional): List of substrings. If any is found in stderr, the error is ignored.\n    \"\"\"\n    total = len(procs)\n    failures = 0\n    print(f\"\\n{total} {title}:\")\n    for idx, (path, result) in enumerate(procs.items(), start=1):\n        stderr = result.stderr or \"\"\n        stdout = result.stdout or \"\"\n        ignored = any(ignore in stderr for ignore in ignores)\n        has_error = (stderr and not ignored) or (\"Error\" in stdout)\n        if has_error:\n            symbol = \"\u274c\"\n            failures += 1\n        else:\n            symbol = \"\u2705\"\n        print(f\"{symbol} {idx}/{total}: {path.name}\")\n    percent_ok = ((total - failures) / total) * 100 if total &gt; 0 else 0\n    print(f\"\\n\u2705 {total - failures}/{total} ({percent_ok:.1f}%), \u274c {failures}/{total} ({100 - percent_ok:.1f}%)\")\n</code></pre>"},{"location":"#omnigraph.shell.Shell.run","title":"<code>run(cmd, text=True, debug=False, tee=False)</code>","text":"<p>Run command with profile, always capturing output and optionally teeing it.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <p>Command to run</p> required <code>text</code> <p>Text mode for subprocess I/O</p> <code>True</code> <code>debug</code> <p>Print the command to be run</p> <code>False</code> <code>tee</code> <p>If True, also print output live while capturing</p> <code>False</code> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess</p> Source code in <code>omnigraph/shell.py</code> <pre><code>    def run(self, cmd, text=True, debug=False, tee=False) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Run command with profile, always capturing output and optionally teeing it.\n\n        Args:\n            cmd: Command to run\n            text: Text mode for subprocess I/O\n            debug: Print the command to be run\n            tee: If True, also print output live while capturing\n\n        Returns:\n            subprocess.CompletedProcess\n        \"\"\"\n        shell_cmd = f\"source {self.profile} &amp;&amp; {cmd}\" if self.profile else cmd\n\n        if debug:\n            print(f\"Running: {shell_cmd}\")\n\n        popen_process = subprocess.Popen(\n            [self.shell_path, \"-c\", shell_cmd],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=text,\n        )\n\n        std_tee = StdTee.run(popen_process, tee=tee)\n        returncode = popen_process.wait()\n\n        process = subprocess.CompletedProcess(\n            args=popen_process.args,\n            returncode=returncode,\n            stdout=std_tee.stdout_buffer.getvalue(),\n            stderr=std_tee.stderr_buffer.getvalue(),\n        )\n\n        if process.returncode != 0:\n            if debug:\n                msg = f\"\"\"{process.args} failed:\n  returncode: {process.returncode}\n  stdout    : {process.stdout.strip()}\n  stderr    : {process.stderr.strip()}\n\"\"\"\n                print(msg, file=sys.stderr)\n            pass\n\n        return process\n</code></pre>"},{"location":"#omnigraph.shell.StdTee","title":"<code>StdTee</code>","text":"<p>Manages teeing for both stdout and stderr using StreamTee instances. Captures output in instance variables.</p> Source code in <code>omnigraph/shell.py</code> <pre><code>class StdTee:\n    \"\"\"\n    Manages teeing for both stdout and stderr using StreamTee instances.\n    Captures output in instance variables.\n    \"\"\"\n\n    def __init__(self, process, tee=True):\n        self.stdout_buffer = io.StringIO()\n        self.stderr_buffer = io.StringIO()\n        self.out_tee = StreamTee(process.stdout, sys.stdout, self.stdout_buffer, tee)\n        self.err_tee = StreamTee(process.stderr, sys.stderr, self.stderr_buffer, tee)\n\n    def start(self):\n        self.out_tee.start()\n        self.err_tee.start()\n\n    def join(self):\n        self.out_tee.join()\n        self.err_tee.join()\n\n    @classmethod\n    def run(cls, process, tee=True):\n        \"\"\"\n        Run teeing and capture for the given process.\n        Returns a StdTee instance with stdout/stderr captured.\n        \"\"\"\n        std_tee = cls(process, tee=tee)\n        std_tee.start()\n        std_tee.join()\n        return std_tee\n</code></pre>"},{"location":"#omnigraph.shell.StdTee.run","title":"<code>run(process, tee=True)</code>  <code>classmethod</code>","text":"<p>Run teeing and capture for the given process. Returns a StdTee instance with stdout/stderr captured.</p> Source code in <code>omnigraph/shell.py</code> <pre><code>@classmethod\ndef run(cls, process, tee=True):\n    \"\"\"\n    Run teeing and capture for the given process.\n    Returns a StdTee instance with stdout/stderr captured.\n    \"\"\"\n    std_tee = cls(process, tee=tee)\n    std_tee.start()\n    std_tee.join()\n    return std_tee\n</code></pre>"},{"location":"#omnigraph.shell.StreamTee","title":"<code>StreamTee</code>","text":"<p>Tees a single input stream to both a mirror and a capture buffer.</p> Source code in <code>omnigraph/shell.py</code> <pre><code>class StreamTee:\n    \"\"\"\n    Tees a single input stream to both a mirror and a capture buffer.\n    \"\"\"\n\n    def __init__(self, source, mirror, buffer, tee=True):\n        self.source = source\n        self.mirror = mirror\n        self.buffer = buffer\n        self.tee = tee\n        self.thread = threading.Thread(target=self._run, daemon=True)\n\n    def _run(self):\n        for line in iter(self.source.readline, \"\"):\n            if self.tee:\n                self.mirror.write(line)\n                self.mirror.flush()\n            self.buffer.write(line)\n        self.source.close()\n\n    def start(self):\n        self.thread.start()\n\n    def join(self):\n        self.thread.join()\n</code></pre>"},{"location":"#omnigraph.shell.SysTee","title":"<code>SysTee</code>","text":"<p>Tee sys.stdout and sys.stderr to a logfile while preserving original output.</p> Source code in <code>omnigraph/shell.py</code> <pre><code>class SysTee:\n    \"\"\"\n    Tee sys.stdout and sys.stderr to a logfile while preserving original output.\n    \"\"\"\n\n    def __init__(self, log_path: str):\n        self.logfile = open(log_path, \"a\")\n        self.original_stdout = sys.stdout\n        self.original_stderr = sys.stderr\n        sys.stdout = self\n        sys.stderr = self\n\n    def write(self, data):\n        self.original_stdout.write(data)\n        self.logfile.write(data)\n\n    def flush(self):\n        self.original_stdout.flush()\n        self.logfile.flush()\n\n    def close(self):\n        sys.stdout = self.original_stdout\n        sys.stderr = self.original_stderr\n        self.logfile.close()\n</code></pre>"},{"location":"#omnigraph.sparql_server","title":"<code>sparql_server</code>","text":"<p>Created on 2025-05-27</p> <p>@author: wf</p>"},{"location":"#omnigraph.sparql_server.ServerConfigs","title":"<code>ServerConfigs</code>","text":"<p>Collection of server configurations loaded from YAML.</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>@lod_storable\nclass ServerConfigs:\n    \"\"\"Collection of server configurations loaded from YAML.\"\"\"\n\n    servers: Dict[str, ServerConfig] = field(default_factory=dict)\n\n    @classmethod\n    def ofYaml(cls, yaml_path: str) -&gt; \"ServerConfigs\":\n        \"\"\"Load server configurations from YAML file.\"\"\"\n        server_configs = cls.load_from_yaml_file(yaml_path)\n        return server_configs\n</code></pre>"},{"location":"#omnigraph.sparql_server.ServerConfigs.ofYaml","title":"<code>ofYaml(yaml_path)</code>  <code>classmethod</code>","text":"<p>Load server configurations from YAML file.</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>@classmethod\ndef ofYaml(cls, yaml_path: str) -&gt; \"ServerConfigs\":\n    \"\"\"Load server configurations from YAML file.\"\"\"\n    server_configs = cls.load_from_yaml_file(yaml_path)\n    return server_configs\n</code></pre>"},{"location":"#omnigraph.sparql_server.ServerEnv","title":"<code>ServerEnv</code>","text":"<p>Server environment configuration.</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>class ServerEnv:\n    \"\"\"\n    Server environment configuration.\n    \"\"\"\n\n    def __init__(self, log: Log = None, shell: Shell = None, debug: bool = False, verbose: bool = False):\n        \"\"\"\n        Initialize server environment.\n\n        Args:\n            log: Log instance for logging\n            shell: Shell instance for command execution\n            debug: Enable debug mode\n            verbose: Enable verbose output\n        \"\"\"\n        if log is None:\n            log=Log()\n        self.log = log\n        if shell is None:\n            shell=Shell()\n        self.shell = shell\n        self.debug = debug\n        self.verbose = verbose\n</code></pre>"},{"location":"#omnigraph.sparql_server.ServerEnv.__init__","title":"<code>__init__(log=None, shell=None, debug=False, verbose=False)</code>","text":"<p>Initialize server environment.</p> <p>Parameters:</p> Name Type Description Default <code>log</code> <code>Log</code> <p>Log instance for logging</p> <code>None</code> <code>shell</code> <code>Shell</code> <p>Shell instance for command execution</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug mode</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Enable verbose output</p> <code>False</code> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def __init__(self, log: Log = None, shell: Shell = None, debug: bool = False, verbose: bool = False):\n    \"\"\"\n    Initialize server environment.\n\n    Args:\n        log: Log instance for logging\n        shell: Shell instance for command execution\n        debug: Enable debug mode\n        verbose: Enable verbose output\n    \"\"\"\n    if log is None:\n        log=Log()\n    self.log = log\n    if shell is None:\n        shell=Shell()\n    self.shell = shell\n    self.debug = debug\n    self.verbose = verbose\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer","title":"<code>SparqlServer</code>","text":"<p>Base class for dockerized SPARQL servers</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>class SparqlServer:\n    \"\"\"\n    Base class for dockerized SPARQL servers\n    \"\"\"\n\n    def __init__(\n        self,\n        config: ServerConfig,\n        env:ServerEnv\n    ):\n        \"\"\"\n        Initialize the SPARQL server manager.\n\n        \"\"\"\n        self.log = env.log\n        self.config = config\n        self.name = self.config.name\n        self.debug = env.debug\n        self.verbose=env.verbose\n        self.shell = env.shell\n\n        # Subclasses must set these URLs\n        if self.config.sparql_url:\n            self.sparql = SPARQL(self.config.sparql_url)\n\n    def _make_request(self, method: str, url: str, timeout: int = 30, **kwargs) -&gt; dict:\n        \"\"\"\n        Helper function for making HTTP requests with consistent error handling.\n\n        Args:\n            method: HTTP method (GET, POST, etc.)\n            url: Request URL\n            timeout: Request timeout in seconds\n            **kwargs: Additional arguments for requests\n\n        Returns:\n            Dictionary with 'success', 'status_code', 'content', and optional 'error'\n        \"\"\"\n        request_result = {}\n        try:\n            response = requests.request(method, url, timeout=timeout, **kwargs)\n            request_result = {\n                \"success\": response.status_code in [200, 204],\n                \"status_code\": response.status_code,\n                \"content\": response.text,\n                \"response\": response,\n            }\n        except Exception as e:\n            request_result = {\n                \"success\": False,\n                \"status_code\": None,\n                \"content\": None,\n                \"error\": str(e),\n            }\n        return request_result\n\n    def run_shell_command(self, command: str, success_msg: str = None, error_msg: str = None) -&gt; bool:\n        \"\"\"\n        Helper function for running shell commands with consistent error handling.\n\n        Args:\n            command: Shell command to run\n            success_msg: Message to log on success\n            error_msg: Message to log on error\n\n        Returns:\n            True if command succeeded (returncode 0)\n        \"\"\"\n        container_name = self.config.container_name\n        command_success = False\n        try:\n            result = self.shell.run(command, debug=self.debug, tee=self.verbose)\n            if result.returncode == 0:\n                if success_msg:\n                    self.log.log(\"\u2705\", container_name, success_msg)\n                command_success = True\n            else:\n                error_detail = error_msg or f\"Command failed: {command}\"\n                if result.stderr:\n                    error_detail += f\" - {result.stderr}\"\n                self.log.log(\"\u274c\", container_name, error_detail)\n                command_success = False\n        except Exception as e:\n            self.log.log(\"\u274c\", container_name, f\"Exception running command '{command}': {e}\")\n            command_success = False\n        return command_success\n\n    def start(self, show_progress: bool = True) -&gt; bool:\n        \"\"\"\n        Start SPARQL server in Docker container.\n\n        Args:\n            show_progress: Show progress bar while waiting\n\n        Returns:\n            True if started successfully\n        \"\"\"\n        container_name = self.config.container_name\n        server_name = self.config.name\n        start_success = False\n        try:\n            if self.is_running():\n                self.log.log(\n                    \"\u2705\",\n                    container_name,\n                    f\"Container {container_name} is already running\",\n                )\n                start_success = self.wait_until_ready(show_progress=show_progress)\n            elif self.exists():\n                self.log.log(\n                    \"\u2705\",\n                    container_name,\n                    f\"Container {container_name} exists, starting...\",\n                )\n                start_cmd = f\"docker start {container_name}\"\n                start_result = self.run_shell_command(\n                    start_cmd,\n                    error_msg=f\"Failed to start container {container_name}\",\n                )\n                if start_result:\n                    start_success = self.wait_until_ready(show_progress=show_progress)\n                else:\n                    start_success = False\n            else:\n                self.log.log(\n                    \"\u2705\",\n                    container_name,\n                    f\"Creating new {server_name} container {container_name}...\",\n                )\n                create_cmd = self.config.docker_run_command\n                create_result = self.run_shell_command(\n                    create_cmd,\n                    error_msg=f\"Failed to create container {container_name}\",\n                )\n                if create_result:\n                    start_success = self.wait_until_ready(show_progress=show_progress)\n                else:\n                    start_success = False\n        except Exception as e:\n            self.log.log(\n                \"\u274c\",\n                container_name,\n                f\"Error starting {server_name}: {e}\",\n            )\n            start_success = False\n        return start_success\n\n    def count_triples(self) -&gt; int:\n        \"\"\"\n        Count total triples in the SPARQL server.\n\n        Returns:\n            Number of triples\n        \"\"\"\n        count_query = \"SELECT (COUNT(*) AS ?count) WHERE { ?s ?p ?o }\"\n        result = self.sparql.getValue(count_query, \"count\")\n        triple_count = int(result) if result else 0\n        return triple_count\n\n    def wait_until_ready(self, timeout: int = 30, show_progress: bool = False) -&gt; bool:\n        \"\"\"\n        Wait for server to be ready.\n\n        Args:\n            timeout: Maximum seconds to wait\n            show_progress: Show progress bar while waiting\n\n        Returns:\n            True if ready within timeout\n        \"\"\"\n        container_name = self.config.container_name\n        server_name = self.config.name\n        status_url = self.config.status_url\n        base_url = self.config.base_url\n\n        self.log.log(\n            \"\u2705\",\n            container_name,\n            f\"Waiting for {server_name} to start ... {status_url}\",\n        )\n\n        pbar = None\n        if show_progress:\n            pbar = tqdm(total=timeout, desc=f\"Waiting for {server_name}\", unit=\"s\")\n\n        ready_status = False\n        for i in range(timeout):\n            status_dict = self.status()\n            if status_dict.get(\"status\") == \"ready\":\n                if show_progress and pbar:\n                    pbar.close()\n                self.log.log(\n                    \"\u2705\",\n                    container_name,\n                    f\"{server_name} ready at {base_url}\",\n                )\n                ready_status = True\n                break\n\n            if show_progress and pbar:\n                pbar.update(1)\n            time.sleep(1)\n\n        if not ready_status:\n            if show_progress and pbar:\n                pbar.close()\n            self.log.log(\n                \"\u26a0\ufe0f\",\n                container_name,\n                f\"Timeout waiting for {server_name} to start after {timeout}s\",\n            )\n\n        return ready_status\n\n    def is_running(self) -&gt; bool:\n        \"\"\"\n        Check if container is currently running.\n\n        Returns:\n            True if container is running\n        \"\"\"\n        running_cmd = f'docker ps --filter \"name={self.config.container_name}\" --format \"{{{{.Names}}}}\"'\n        result = self.shell.run(running_cmd, debug=self.debug)\n        is_container_running = self.config.container_name in result.stdout\n        return is_container_running\n\n    def exists(self) -&gt; bool:\n        \"\"\"\n        Check if container exists (running or stopped).\n\n        Returns:\n            True if container exists\n        \"\"\"\n        container_name = self.config.container_name\n        check_cmd = f'docker ps -a --filter \"name={container_name}\" --format \"{{{{.Names}}}}\"'\n        result = self.shell.run(check_cmd, debug=self.debug)\n        if result.stderr:\n            self.log.log(\"\u274c\", container_name, result.stderr)\n        container_exists = container_name in result.stdout\n        return container_exists\n\n    def stop(self) -&gt; bool:\n        \"\"\"\n        Stop the server container.\n\n        Returns:\n            True if stopped successfully\n        \"\"\"\n        container_name=self.config.container_name\n        stop_cmd = f\"docker stop {container_name}\"\n        stop_success = self.run_shell_command(\n            stop_cmd,\n            success_msg=f\"Stopped container {container_name}\",\n            error_msg=f\"Failed to stop container {container_name}\",\n        )\n        return stop_success\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.__init__","title":"<code>__init__(config, env)</code>","text":"<p>Initialize the SPARQL server manager.</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def __init__(\n    self,\n    config: ServerConfig,\n    env:ServerEnv\n):\n    \"\"\"\n    Initialize the SPARQL server manager.\n\n    \"\"\"\n    self.log = env.log\n    self.config = config\n    self.name = self.config.name\n    self.debug = env.debug\n    self.verbose=env.verbose\n    self.shell = env.shell\n\n    # Subclasses must set these URLs\n    if self.config.sparql_url:\n        self.sparql = SPARQL(self.config.sparql_url)\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.count_triples","title":"<code>count_triples()</code>","text":"<p>Count total triples in the SPARQL server.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of triples</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def count_triples(self) -&gt; int:\n    \"\"\"\n    Count total triples in the SPARQL server.\n\n    Returns:\n        Number of triples\n    \"\"\"\n    count_query = \"SELECT (COUNT(*) AS ?count) WHERE { ?s ?p ?o }\"\n    result = self.sparql.getValue(count_query, \"count\")\n    triple_count = int(result) if result else 0\n    return triple_count\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.exists","title":"<code>exists()</code>","text":"<p>Check if container exists (running or stopped).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if container exists</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"\n    Check if container exists (running or stopped).\n\n    Returns:\n        True if container exists\n    \"\"\"\n    container_name = self.config.container_name\n    check_cmd = f'docker ps -a --filter \"name={container_name}\" --format \"{{{{.Names}}}}\"'\n    result = self.shell.run(check_cmd, debug=self.debug)\n    if result.stderr:\n        self.log.log(\"\u274c\", container_name, result.stderr)\n    container_exists = container_name in result.stdout\n    return container_exists\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.is_running","title":"<code>is_running()</code>","text":"<p>Check if container is currently running.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if container is running</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def is_running(self) -&gt; bool:\n    \"\"\"\n    Check if container is currently running.\n\n    Returns:\n        True if container is running\n    \"\"\"\n    running_cmd = f'docker ps --filter \"name={self.config.container_name}\" --format \"{{{{.Names}}}}\"'\n    result = self.shell.run(running_cmd, debug=self.debug)\n    is_container_running = self.config.container_name in result.stdout\n    return is_container_running\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.run_shell_command","title":"<code>run_shell_command(command, success_msg=None, error_msg=None)</code>","text":"<p>Helper function for running shell commands with consistent error handling.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Shell command to run</p> required <code>success_msg</code> <code>str</code> <p>Message to log on success</p> <code>None</code> <code>error_msg</code> <code>str</code> <p>Message to log on error</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if command succeeded (returncode 0)</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def run_shell_command(self, command: str, success_msg: str = None, error_msg: str = None) -&gt; bool:\n    \"\"\"\n    Helper function for running shell commands with consistent error handling.\n\n    Args:\n        command: Shell command to run\n        success_msg: Message to log on success\n        error_msg: Message to log on error\n\n    Returns:\n        True if command succeeded (returncode 0)\n    \"\"\"\n    container_name = self.config.container_name\n    command_success = False\n    try:\n        result = self.shell.run(command, debug=self.debug, tee=self.verbose)\n        if result.returncode == 0:\n            if success_msg:\n                self.log.log(\"\u2705\", container_name, success_msg)\n            command_success = True\n        else:\n            error_detail = error_msg or f\"Command failed: {command}\"\n            if result.stderr:\n                error_detail += f\" - {result.stderr}\"\n            self.log.log(\"\u274c\", container_name, error_detail)\n            command_success = False\n    except Exception as e:\n        self.log.log(\"\u274c\", container_name, f\"Exception running command '{command}': {e}\")\n        command_success = False\n    return command_success\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.start","title":"<code>start(show_progress=True)</code>","text":"<p>Start SPARQL server in Docker container.</p> <p>Parameters:</p> Name Type Description Default <code>show_progress</code> <code>bool</code> <p>Show progress bar while waiting</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if started successfully</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def start(self, show_progress: bool = True) -&gt; bool:\n    \"\"\"\n    Start SPARQL server in Docker container.\n\n    Args:\n        show_progress: Show progress bar while waiting\n\n    Returns:\n        True if started successfully\n    \"\"\"\n    container_name = self.config.container_name\n    server_name = self.config.name\n    start_success = False\n    try:\n        if self.is_running():\n            self.log.log(\n                \"\u2705\",\n                container_name,\n                f\"Container {container_name} is already running\",\n            )\n            start_success = self.wait_until_ready(show_progress=show_progress)\n        elif self.exists():\n            self.log.log(\n                \"\u2705\",\n                container_name,\n                f\"Container {container_name} exists, starting...\",\n            )\n            start_cmd = f\"docker start {container_name}\"\n            start_result = self.run_shell_command(\n                start_cmd,\n                error_msg=f\"Failed to start container {container_name}\",\n            )\n            if start_result:\n                start_success = self.wait_until_ready(show_progress=show_progress)\n            else:\n                start_success = False\n        else:\n            self.log.log(\n                \"\u2705\",\n                container_name,\n                f\"Creating new {server_name} container {container_name}...\",\n            )\n            create_cmd = self.config.docker_run_command\n            create_result = self.run_shell_command(\n                create_cmd,\n                error_msg=f\"Failed to create container {container_name}\",\n            )\n            if create_result:\n                start_success = self.wait_until_ready(show_progress=show_progress)\n            else:\n                start_success = False\n    except Exception as e:\n        self.log.log(\n            \"\u274c\",\n            container_name,\n            f\"Error starting {server_name}: {e}\",\n        )\n        start_success = False\n    return start_success\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.stop","title":"<code>stop()</code>","text":"<p>Stop the server container.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if stopped successfully</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def stop(self) -&gt; bool:\n    \"\"\"\n    Stop the server container.\n\n    Returns:\n        True if stopped successfully\n    \"\"\"\n    container_name=self.config.container_name\n    stop_cmd = f\"docker stop {container_name}\"\n    stop_success = self.run_shell_command(\n        stop_cmd,\n        success_msg=f\"Stopped container {container_name}\",\n        error_msg=f\"Failed to stop container {container_name}\",\n    )\n    return stop_success\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.wait_until_ready","title":"<code>wait_until_ready(timeout=30, show_progress=False)</code>","text":"<p>Wait for server to be ready.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Maximum seconds to wait</p> <code>30</code> <code>show_progress</code> <code>bool</code> <p>Show progress bar while waiting</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if ready within timeout</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def wait_until_ready(self, timeout: int = 30, show_progress: bool = False) -&gt; bool:\n    \"\"\"\n    Wait for server to be ready.\n\n    Args:\n        timeout: Maximum seconds to wait\n        show_progress: Show progress bar while waiting\n\n    Returns:\n        True if ready within timeout\n    \"\"\"\n    container_name = self.config.container_name\n    server_name = self.config.name\n    status_url = self.config.status_url\n    base_url = self.config.base_url\n\n    self.log.log(\n        \"\u2705\",\n        container_name,\n        f\"Waiting for {server_name} to start ... {status_url}\",\n    )\n\n    pbar = None\n    if show_progress:\n        pbar = tqdm(total=timeout, desc=f\"Waiting for {server_name}\", unit=\"s\")\n\n    ready_status = False\n    for i in range(timeout):\n        status_dict = self.status()\n        if status_dict.get(\"status\") == \"ready\":\n            if show_progress and pbar:\n                pbar.close()\n            self.log.log(\n                \"\u2705\",\n                container_name,\n                f\"{server_name} ready at {base_url}\",\n            )\n            ready_status = True\n            break\n\n        if show_progress and pbar:\n            pbar.update(1)\n        time.sleep(1)\n\n    if not ready_status:\n        if show_progress and pbar:\n            pbar.close()\n        self.log.log(\n            \"\u26a0\ufe0f\",\n            container_name,\n            f\"Timeout waiting for {server_name} to start after {timeout}s\",\n        )\n\n    return ready_status\n</code></pre>"},{"location":"#omnigraph.version","title":"<code>version</code>","text":"<p>Created on 2025-05-28</p> <p>@author: wf</p>"},{"location":"#omnigraph.version.Version","title":"<code>Version</code>","text":"<p>Version handling for nicegui widgets</p> Source code in <code>omnigraph/version.py</code> <pre><code>@lod_storable\nclass Version:\n    \"\"\"\n    Version handling for nicegui widgets\n    \"\"\"\n\n    name = \"omnigraph\"\n    version = omnigraph.__version__\n    date = \"2025-05-27\"\n    updated = \"2025-05-28\"\n    description = \"Unified Python interface for multiple graph databases\"\n\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/pyomnigraph\"\n    chat_url = \"https://github.com/WolfgangFahl/pyomnigraph/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/pyomnigraph\"\n\n    license = f\"\"\"Copyright 2025 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#omnigraph.yamlable","title":"<code>yamlable</code>","text":"<p>This is redundant copy to avoid dependeny hell the original is at https://github.com/WolfgangFahl/nicegui_widgets/blob/main/ngwidgets/yamlable.py</p> <p>Created on 2023-12-08, Extended on 2023-16-12 and 2024-01-25</p> <p>@author: wf, ChatGPT</p> <p>Prompts for the development and extension of the 'YamlAble' class within the 'yamable' module:</p> <ol> <li>Develop 'YamlAble' class in 'yamable' module. It    should convert dataclass instances to/from YAML.</li> <li>Implement methods for YAML block scalar style and    exclude None values in 'YamlAble' class.</li> <li>Add functionality to remove None values from    dataclass instances before YAML conversion.</li> <li>Ensure 'YamlAble' processes only dataclass instances,    with error handling for non-dataclass objects.</li> <li>Extend 'YamlAble' for JSON serialization and    deserialization.</li> <li>Add methods for saving/loading dataclass instances    to/from YAML and JSON files in 'YamlAble'.</li> <li>Implement loading of dataclass instances from URLs    for both YAML and JSON in 'YamlAble'.</li> <li>Write tests for 'YamlAble' within the pyLodStorage context.    Use 'samples 2' example from pyLoDStorage    https://github.com/WolfgangFahl/pyLoDStorage/blob/master/lodstorage/sample2.py    as a reference.</li> <li>Ensure tests cover YAML/JSON serialization, deserialization,    and file I/O operations, using the sample-based approach..</li> <li>Use Google-style docstrings, comments, and type hints    in 'YamlAble' class and tests.</li> <li>Adhere to instructions and seek clarification for     any uncertainties.</li> <li>Add @lod_storable annotation support that will automatically     YamlAble support and add @dataclass and @dataclass_json     prerequisite behavior to a class</li> </ol>"},{"location":"#omnigraph.yamlable.DateConvert","title":"<code>DateConvert</code>","text":"<p>date converter</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>class DateConvert:\n    \"\"\"\n    date converter\n    \"\"\"\n\n    @classmethod\n    def iso_date_to_datetime(cls, iso_date: str) -&gt; datetime.date:\n        date = datetime.strptime(iso_date, \"%Y-%m-%d\").date() if iso_date else None\n        return date\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble","title":"<code>YamlAble</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>An extended YAML handler class for converting dataclass objects to and from YAML format, and handling loading from and saving to files and URLs.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>class YamlAble(Generic[T]):\n    \"\"\"\n    An extended YAML handler class for converting dataclass objects to and from YAML format,\n    and handling loading from and saving to files and URLs.\n    \"\"\"\n\n    def _yaml_setup(self):\n        \"\"\"\n        Initializes the YamAble handler, setting up custom representers and preparing it for various operations.\n        \"\"\"\n        if not is_dataclass(self):\n            raise ValueError(\"I must be a dataclass instance.\")\n        if not hasattr(self, \"_yaml_dumper\"):\n            self._yaml_dumper = yaml.Dumper\n            self._yaml_dumper.ignore_aliases = lambda *_args: True\n            self._yaml_dumper.add_representer(type(None), self.represent_none)\n            self._yaml_dumper.add_representer(str, self.represent_literal)\n\n    def represent_none(self, _, __) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for ignoring None values in the YAML output.\n        \"\"\"\n        return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n\n    def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for block scalar style for strings.\n        \"\"\"\n        if \"\\n\" in data:\n            return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n\n    def to_yaml(\n        self,\n        ignore_none: bool = True,\n        ignore_underscore: bool = True,\n        allow_unicode: bool = True,\n        sort_keys: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n        and using block scalar style for strings.\n\n        Args:\n            ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n            ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n            allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n            sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n        Returns:\n            A string representation of the dataclass object in YAML format.\n        \"\"\"\n        obj_dict = asdict(self)\n        self._yaml_setup()\n        clean_dict = self.remove_ignored_values(obj_dict, ignore_none, ignore_underscore)\n        yaml_str = yaml.dump(\n            clean_dict,\n            Dumper=self._yaml_dumper,\n            default_flow_style=False,\n            allow_unicode=allow_unicode,\n            sort_keys=sort_keys,\n        )\n        return yaml_str\n\n    @classmethod\n    def from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n        \"\"\"\n        Deserializes a YAML string to a dataclass instance.\n\n        Args:\n            yaml_str (str): A string containing YAML formatted data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        data: dict[str, Any] = yaml.safe_load(yaml_str)\n        instance: T = cls.from_dict(data)\n        return instance\n\n    @classmethod\n    def load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML file.\n\n        Args:\n            filename (str): The path to the YAML file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\") as file:\n            yaml_str: str = file.read()\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    @classmethod\n    def load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the YAML data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        yaml_str: str = cls.read_from_url(url)\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    def save_to_yaml_file(self, filename: str):\n        \"\"\"\n        Saves the current dataclass instance to a YAML file.\n\n        Args:\n            filename (str): The path where the YAML file will be saved.\n        \"\"\"\n        yaml_content: str = self.to_yaml()\n        with open(filename, \"w\") as file:\n            file.write(yaml_content)\n\n    @classmethod\n    def load_from_json_file(cls: Type[T], filename: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON file.\n\n        Args:\n            filename (str): The path to the JSON file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\") as file:\n            json_str: str = file.read()\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    @classmethod\n    def load_from_json_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the JSON data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        json_str: str = cls.read_from_url(url)\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    def save_to_json_file(self, filename: str, **kwargs):\n        \"\"\"\n        Saves the current dataclass instance to a JSON file.\n\n        Args:\n            filename (str): The path where the JSON file will be saved.\n            **kwargs: Additional keyword arguments for the `to_json` method.\n        \"\"\"\n        json_content: str = self.to_json(**kwargs)\n        with open(filename, \"w\") as file:\n            file.write(json_content)\n\n    @classmethod\n    def read_from_url(cls, url: str) -&gt; str:\n        \"\"\"\n        Helper method to fetch content from a URL.\n        \"\"\"\n        with urllib.request.urlopen(url) as response:\n            if response.status == 200:\n                return response.read().decode()\n            else:\n                raise Exception(f\"Unable to load data from URL: {url}\")\n\n    @classmethod\n    def remove_ignored_values(\n        cls,\n        value: Any,\n        ignore_none: bool = True,\n        ignore_underscore: bool = False,\n        ignore_empty: bool = True,\n    ) -&gt; Any:\n        \"\"\"\n        Recursively removes specified types of values from a dictionary or list.\n        By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n        Args:\n            value: The value to process (dictionary, list, or other).\n            ignore_none: Flag to indicate whether None values should be removed.\n            ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n            ignore_empty: Flag to indicate whether empty collections should be removed.\n        \"\"\"\n\n        def is_valid(v):\n            \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n            if ignore_none and v is None:\n                return False\n            if ignore_empty:\n                if isinstance(v, Mapping) and not v:\n                    return False  # Empty dictionary\n                if isinstance(v, Iterable) and not isinstance(v, (str, bytes)) and not v:\n                    return False  # Empty list, set, tuple, etc., but not string or bytes\n            return True\n\n        if isinstance(value, Mapping):\n            value = {\n                k: YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n                for k, v in value.items()\n                if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n            }\n        elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n            value = [\n                YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n                for v in value\n                if is_valid(v)\n            ]\n        return value\n\n    @classmethod\n    def from_dict2(cls: Type[T], data: dict) -&gt; T:\n        \"\"\"\n        Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n        \"\"\"\n        if not data:\n            return None\n        instance = from_dict(data_class=cls, data=data)\n        return instance\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.from_dict2","title":"<code>from_dict2(data)</code>  <code>classmethod</code>","text":"<p>Creates an instance of a dataclass from a dictionary, typically used in deserialization.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>@classmethod\ndef from_dict2(cls: Type[T], data: dict) -&gt; T:\n    \"\"\"\n    Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n    \"\"\"\n    if not data:\n        return None\n    instance = from_dict(data_class=cls, data=data)\n    return instance\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.from_yaml","title":"<code>from_yaml(yaml_str)</code>  <code>classmethod</code>","text":"<p>Deserializes a YAML string to a dataclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_str</code> <code>str</code> <p>A string containing YAML formatted data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>@classmethod\ndef from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n    \"\"\"\n    Deserializes a YAML string to a dataclass instance.\n\n    Args:\n        yaml_str (str): A string containing YAML formatted data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    data: dict[str, Any] = yaml.safe_load(yaml_str)\n    instance: T = cls.from_dict(data)\n    return instance\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.load_from_json_file","title":"<code>load_from_json_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_file(cls: Type[T], filename: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON file.\n\n    Args:\n        filename (str): The path to the JSON file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        json_str: str = file.read()\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.load_from_json_url","title":"<code>load_from_json_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the JSON data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the JSON data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    json_str: str = cls.read_from_url(url)\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.load_from_yaml_file","title":"<code>load_from_yaml_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML file.\n\n    Args:\n        filename (str): The path to the YAML file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        yaml_str: str = file.read()\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.load_from_yaml_url","title":"<code>load_from_yaml_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the YAML data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the YAML data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    yaml_str: str = cls.read_from_url(url)\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.read_from_url","title":"<code>read_from_url(url)</code>  <code>classmethod</code>","text":"<p>Helper method to fetch content from a URL.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>@classmethod\ndef read_from_url(cls, url: str) -&gt; str:\n    \"\"\"\n    Helper method to fetch content from a URL.\n    \"\"\"\n    with urllib.request.urlopen(url) as response:\n        if response.status == 200:\n            return response.read().decode()\n        else:\n            raise Exception(f\"Unable to load data from URL: {url}\")\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.remove_ignored_values","title":"<code>remove_ignored_values(value, ignore_none=True, ignore_underscore=False, ignore_empty=True)</code>  <code>classmethod</code>","text":"<p>Recursively removes specified types of values from a dictionary or list. By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to process (dictionary, list, or other).</p> required <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether keys starting with an underscore should be removed.</p> <code>False</code> <code>ignore_empty</code> <code>bool</code> <p>Flag to indicate whether empty collections should be removed.</p> <code>True</code> Source code in <code>omnigraph/yamlable.py</code> <pre><code>@classmethod\ndef remove_ignored_values(\n    cls,\n    value: Any,\n    ignore_none: bool = True,\n    ignore_underscore: bool = False,\n    ignore_empty: bool = True,\n) -&gt; Any:\n    \"\"\"\n    Recursively removes specified types of values from a dictionary or list.\n    By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n    Args:\n        value: The value to process (dictionary, list, or other).\n        ignore_none: Flag to indicate whether None values should be removed.\n        ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n        ignore_empty: Flag to indicate whether empty collections should be removed.\n    \"\"\"\n\n    def is_valid(v):\n        \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n        if ignore_none and v is None:\n            return False\n        if ignore_empty:\n            if isinstance(v, Mapping) and not v:\n                return False  # Empty dictionary\n            if isinstance(v, Iterable) and not isinstance(v, (str, bytes)) and not v:\n                return False  # Empty list, set, tuple, etc., but not string or bytes\n        return True\n\n    if isinstance(value, Mapping):\n        value = {\n            k: YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n            for k, v in value.items()\n            if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n        }\n    elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n        value = [\n            YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n            for v in value\n            if is_valid(v)\n        ]\n    return value\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.represent_literal","title":"<code>represent_literal(dumper, data)</code>","text":"<p>Custom representer for block scalar style for strings.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for block scalar style for strings.\n    \"\"\"\n    if \"\\n\" in data:\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n    return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.represent_none","title":"<code>represent_none(_, __)</code>","text":"<p>Custom representer for ignoring None values in the YAML output.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>def represent_none(self, _, __) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for ignoring None values in the YAML output.\n    \"\"\"\n    return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.save_to_json_file","title":"<code>save_to_json_file(filename, **kwargs)</code>","text":"<p>Saves the current dataclass instance to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the JSON file will be saved.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the <code>to_json</code> method.</p> <code>{}</code> Source code in <code>omnigraph/yamlable.py</code> <pre><code>def save_to_json_file(self, filename: str, **kwargs):\n    \"\"\"\n    Saves the current dataclass instance to a JSON file.\n\n    Args:\n        filename (str): The path where the JSON file will be saved.\n        **kwargs: Additional keyword arguments for the `to_json` method.\n    \"\"\"\n    json_content: str = self.to_json(**kwargs)\n    with open(filename, \"w\") as file:\n        file.write(json_content)\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.save_to_yaml_file","title":"<code>save_to_yaml_file(filename)</code>","text":"<p>Saves the current dataclass instance to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the YAML file will be saved.</p> required Source code in <code>omnigraph/yamlable.py</code> <pre><code>def save_to_yaml_file(self, filename: str):\n    \"\"\"\n    Saves the current dataclass instance to a YAML file.\n\n    Args:\n        filename (str): The path where the YAML file will be saved.\n    \"\"\"\n    yaml_content: str = self.to_yaml()\n    with open(filename, \"w\") as file:\n        file.write(yaml_content)\n</code></pre>"},{"location":"#omnigraph.yamlable.YamlAble.to_yaml","title":"<code>to_yaml(ignore_none=True, ignore_underscore=True, allow_unicode=True, sort_keys=False)</code>","text":"<p>Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables, and using block scalar style for strings.</p> <p>Parameters:</p> Name Type Description Default <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed from the YAML output.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.</p> <code>True</code> <code>allow_unicode</code> <code>bool</code> <p>Flag to indicate whether to allow unicode characters in the output.</p> <code>True</code> <code>sort_keys</code> <code>bool</code> <p>Flag to indicate whether to sort the dictionary keys in the output.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the dataclass object in YAML format.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>def to_yaml(\n    self,\n    ignore_none: bool = True,\n    ignore_underscore: bool = True,\n    allow_unicode: bool = True,\n    sort_keys: bool = False,\n) -&gt; str:\n    \"\"\"\n    Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n    and using block scalar style for strings.\n\n    Args:\n        ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n        ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n        allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n        sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n    Returns:\n        A string representation of the dataclass object in YAML format.\n    \"\"\"\n    obj_dict = asdict(self)\n    self._yaml_setup()\n    clean_dict = self.remove_ignored_values(obj_dict, ignore_none, ignore_underscore)\n    yaml_str = yaml.dump(\n        clean_dict,\n        Dumper=self._yaml_dumper,\n        default_flow_style=False,\n        allow_unicode=allow_unicode,\n        sort_keys=sort_keys,\n    )\n    return yaml_str\n</code></pre>"},{"location":"#omnigraph.yamlable.lod_storable","title":"<code>lod_storable(cls)</code>","text":"<p>Decorator to make a class LoDStorable by inheriting from YamlAble. This decorator also ensures the class is a dataclass and has JSON serialization/deserialization capabilities.</p> Source code in <code>omnigraph/yamlable.py</code> <pre><code>def lod_storable(cls):\n    \"\"\"\n    Decorator to make a class LoDStorable by\n    inheriting from YamlAble.\n    This decorator also ensures the class is a\n    dataclass and has JSON serialization/deserialization\n    capabilities.\n    \"\"\"\n    cls = dataclass(cls)  # Apply the @dataclass decorator\n    cls = dataclass_json(cls)  # Apply the @dataclass_json decorator\n\n    class LoDStorable(YamlAble, cls):\n        \"\"\"\n        decorator class\n        \"\"\"\n\n        __qualname__ = cls.__qualname__\n        pass\n\n    LoDStorable.__name__ = cls.__name__\n    LoDStorable.__doc__ = cls.__doc__\n\n    return LoDStorable\n</code></pre>"}]}