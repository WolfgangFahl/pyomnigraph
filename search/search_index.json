{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"omnigraph API Documentation","text":""},{"location":"#omnigraph.ominigraph_paths","title":"<code>ominigraph_paths</code>","text":"<p>Created on 27.05.2025</p> <p>@author: wf</p>"},{"location":"#omnigraph.ominigraph_paths.OmnigraphPaths","title":"<code>OmnigraphPaths</code>","text":"<p>Omnigraph Default Paths</p> Source code in <code>omnigraph/ominigraph_paths.py</code> <pre><code>class OmnigraphPaths:\n    \"\"\"\n    Omnigraph Default Paths\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.home_dir = Path.home()\n        self.omnigraph_dir = self.home_dir / \".omnigraph\"\n        self.omnigraph_dir.mkdir(exist_ok=True)\n        self.examples_dir = (Path(__file__).parent / \"resources\" / \"examples\").resolve()\n</code></pre>"},{"location":"#omnigraph.ominigraph_paths.OmnigraphPaths.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>omnigraph/ominigraph_paths.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.home_dir = Path.home()\n    self.omnigraph_dir = self.home_dir / \".omnigraph\"\n    self.omnigraph_dir.mkdir(exist_ok=True)\n    self.examples_dir = (Path(__file__).parent / \"resources\" / \"examples\").resolve()\n</code></pre>"},{"location":"#omnigraph.sparql_server","title":"<code>sparql_server</code>","text":"<p>Created on 2025-05-27</p> <p>@author: wf</p>"},{"location":"#omnigraph.sparql_server.Blazegraph","title":"<code>Blazegraph</code>","text":"<p>               Bases: <code>SparqlServer</code></p> <p>Dockerized Blazegraph SPARQL server</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>class Blazegraph(SparqlServer):\n    \"\"\"\n    Dockerized Blazegraph SPARQL server\n    \"\"\"\n\n    def __init__(\n        self,\n        config:ServerConfig,\n        log: Log = None,\n        shell: Shell = None,\n        debug: bool = False,\n    ):\n        \"\"\"\n        Initialize the Blazegraph manager.\n\n        Args:\n            log: Log instance for logging\n            shell: Shell instance for Docker commands\n            debug: Enable debug output\n        \"\"\"\n        super().__init__(config=config, log=log, shell=shell, debug=debug)\n        self.dataloader_url = f\"{self.config.base_url}/dataloader\"\n\n    def status(self) -&gt; dict:\n        \"\"\"\n        Get Blazegraph status information.\n\n        Returns:\n            Dictionary with status information, empty dict if error\n        \"\"\"\n        status_dict = {}\n\n        result = self._make_request(\"GET\", self.config.status_url, timeout=2)\n\n        if result[\"success\"]:\n            status_dict[\"status\"] = \"ready\"\n            html_content = result[\"content\"]\n            name_value_pattern = r'(?:&lt;span id=\"(?P&lt;name1&gt;[^\"]+)\"&gt;(?P&lt;value1&gt;[^&lt;]+)&lt;/span[^&gt;]*&gt;|&amp;#47;(?P&lt;name2&gt;[^=]+)=(?P&lt;value2&gt;[^\\s&amp;#]+))'\n            matches = re.finditer(name_value_pattern, html_content, re.DOTALL)\n\n            for match in matches:\n                for name_group, value_group in {\n                    \"name1\": \"value1\",\n                    \"name2\": \"value2\",\n                }.items():\n                    name = match.group(name_group)\n                    if name:\n                        value = match.group(value_group)\n                        sanitized_value = value.replace(\"&lt;/p\", \"\").replace(\"&amp;#47;\", \"/\")\n                        sanitized_name = name.replace(\"-\", \"_\").replace(\"/\", \"_\")\n                        sanitized_name = sanitized_name.replace(\"&amp;#47;\", \"/\")\n                        if not sanitized_name.startswith(\"/\"):\n                            status_dict[sanitized_name] = sanitized_value\n                        break\n        else:\n            if result.get(\"error\"):\n                status_dict[\"status\"] = f\"error: {result['error']}\"\n            else:\n                status_dict[\"status\"] = f\"status_code: {result['status_code']}\"\n\n        return status_dict\n\n    def load_file(self, filepath: str) -&gt; bool:\n        \"\"\"\n        Load a single RDF file into Blazegraph.\n\n        Args:\n            filepath: Path to RDF file\n\n        Returns:\n            True if loaded successfully\n        \"\"\"\n        load_success = False\n        try:\n            with open(filepath, \"rb\") as f:\n                result = self._make_request(\n                    \"POST\",\n                    self.config.sparql_url,\n                    headers={\"Content-Type\": \"text/turtle\"},\n                    data=f.read(),\n                    timeout=300,\n                )\n\n            if result[\"success\"]:\n                self.log.log(\"\u2705\", self.name, f\"Loaded {filepath}\")\n                load_success = True\n            else:\n                error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n                self.log.log(\n                    \"\u274c\", self.name, f\"Failed to load {filepath}: {error_msg}\"\n                )\n                load_success = False\n\n        except Exception as e:\n            self.log.log(\n                \"\u274c\", self.name, f\"Exception loading {filepath}: {e}\"\n            )\n            load_success = False\n\n        return load_success\n\n    def load_files_bulk(self, file_list: list) -&gt; bool:\n        \"\"\"\n        Load multiple files using Blazegraph's bulk loader REST API.\n\n        Args:\n            file_list: List of file paths to load\n\n        Returns:\n            True if loaded successfully\n        \"\"\"\n        bulk_load_success = False\n\n        if not file_list:\n            bulk_load_success = False\n        else:\n            # Convert to absolute paths\n            abs_paths = [str(Path(f).absolute()) for f in file_list]\n\n            properties = f\"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n            &lt;properties&gt;\n                &lt;entry key=\"format\"&gt;turtle&lt;/entry&gt;\n                &lt;entry key=\"quiet\"&gt;false&lt;/entry&gt;\n                &lt;entry key=\"verbose\"&gt;1&lt;/entry&gt;\n                &lt;entry key=\"namespace\"&gt;kb&lt;/entry&gt;\n                &lt;entry key=\"fileOrDirs\"&gt;{','.join(abs_paths)}&lt;/entry&gt;\n            &lt;/properties&gt;\"\"\"\n\n            result = self._make_request(\n                \"POST\",\n                self.dataloader_url,\n                headers={\"Content-Type\": \"application/xml\"},\n                data=properties,\n                timeout=3600,\n            )\n\n            if result[\"success\"]:\n                self.log.log(\n                    \"\u2705\", self.container_name, f\"Bulk loaded {len(file_list)} files\"\n                )\n                bulk_load_success = True\n            else:\n                error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n                self.log.log(\n                    \"\u274c\", self.container_name, f\"Bulk load failed: {error_msg}\"\n                )\n                bulk_load_success = False\n\n        return bulk_load_success\n\n    def load_dump_files(\n        self, file_pattern: str = \"dump_*.ttl\", use_bulk: bool = True\n    ) -&gt; int:\n        \"\"\"\n        Load all dump files matching pattern.\n\n        Args:\n            file_pattern: Glob pattern for dump files\n            use_bulk: Use bulk loader if True, individual files if False\n\n        Returns:\n            Number of files loaded successfully\n        \"\"\"\n        files = sorted(glob.glob(file_pattern))\n        loaded_count = 0\n\n        if not files:\n            self.log.log(\n                \"\u26a0\ufe0f\",\n                self.container_name,\n                f\"No files found matching pattern: {file_pattern}\",\n            )\n            loaded_count = 0\n        else:\n            self.log.log(\"\u2705\", self.container_name, f\"Found {len(files)} files to load\")\n\n            if use_bulk:\n                bulk_result = self.load_files_bulk(files)\n                loaded_count = len(files) if bulk_result else 0\n            else:\n                loaded_count = 0\n                for filepath in tqdm(files, desc=\"Loading files\"):\n                    file_result = self.load_file(filepath)\n                    if file_result:\n                        loaded_count += 1\n                    else:\n                        self.log.log(\n                            \"\u274c\", self.container_name, f\"Failed to load: {filepath}\"\n                        )\n\n        return loaded_count\n\n    def test_geosparql(self) -&gt; bool:\n        \"\"\"\n        Test if GeoSPARQL functions work.\n\n        Returns:\n            True if GeoSPARQL is available\n        \"\"\"\n        test_query = \"\"\"\n        PREFIX geo: &lt;http://www.opengis.net/ont/geosparql#&gt;\n        PREFIX geof: &lt;http://www.opengis.net/def/function/geosparql/&gt;\n\n        SELECT * WHERE {\n            BIND(geof:distance(\"POINT(0 0)\"^^geo:wktLiteral, \"POINT(1 1)\"^^geo:wktLiteral) AS ?dist)\n        } LIMIT 1\n        \"\"\"\n\n        result = self._make_request(\n            \"POST\",\n            self.sparql_url,\n            data={\"query\": test_query},\n            headers={\"Accept\": \"application/sparql-results+json\"},\n            timeout=10,\n        )\n\n        geosparql_available = result[\"success\"]\n        return geosparql_available\n</code></pre>"},{"location":"#omnigraph.sparql_server.Blazegraph.__init__","title":"<code>__init__(config, log=None, shell=None, debug=False)</code>","text":"<p>Initialize the Blazegraph manager.</p> <p>Parameters:</p> Name Type Description Default <code>log</code> <code>Log</code> <p>Log instance for logging</p> <code>None</code> <code>shell</code> <code>Shell</code> <p>Shell instance for Docker commands</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug output</p> <code>False</code> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def __init__(\n    self,\n    config:ServerConfig,\n    log: Log = None,\n    shell: Shell = None,\n    debug: bool = False,\n):\n    \"\"\"\n    Initialize the Blazegraph manager.\n\n    Args:\n        log: Log instance for logging\n        shell: Shell instance for Docker commands\n        debug: Enable debug output\n    \"\"\"\n    super().__init__(config=config, log=log, shell=shell, debug=debug)\n    self.dataloader_url = f\"{self.config.base_url}/dataloader\"\n</code></pre>"},{"location":"#omnigraph.sparql_server.Blazegraph.load_dump_files","title":"<code>load_dump_files(file_pattern='dump_*.ttl', use_bulk=True)</code>","text":"<p>Load all dump files matching pattern.</p> <p>Parameters:</p> Name Type Description Default <code>file_pattern</code> <code>str</code> <p>Glob pattern for dump files</p> <code>'dump_*.ttl'</code> <code>use_bulk</code> <code>bool</code> <p>Use bulk loader if True, individual files if False</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of files loaded successfully</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def load_dump_files(\n    self, file_pattern: str = \"dump_*.ttl\", use_bulk: bool = True\n) -&gt; int:\n    \"\"\"\n    Load all dump files matching pattern.\n\n    Args:\n        file_pattern: Glob pattern for dump files\n        use_bulk: Use bulk loader if True, individual files if False\n\n    Returns:\n        Number of files loaded successfully\n    \"\"\"\n    files = sorted(glob.glob(file_pattern))\n    loaded_count = 0\n\n    if not files:\n        self.log.log(\n            \"\u26a0\ufe0f\",\n            self.container_name,\n            f\"No files found matching pattern: {file_pattern}\",\n        )\n        loaded_count = 0\n    else:\n        self.log.log(\"\u2705\", self.container_name, f\"Found {len(files)} files to load\")\n\n        if use_bulk:\n            bulk_result = self.load_files_bulk(files)\n            loaded_count = len(files) if bulk_result else 0\n        else:\n            loaded_count = 0\n            for filepath in tqdm(files, desc=\"Loading files\"):\n                file_result = self.load_file(filepath)\n                if file_result:\n                    loaded_count += 1\n                else:\n                    self.log.log(\n                        \"\u274c\", self.container_name, f\"Failed to load: {filepath}\"\n                    )\n\n    return loaded_count\n</code></pre>"},{"location":"#omnigraph.sparql_server.Blazegraph.load_file","title":"<code>load_file(filepath)</code>","text":"<p>Load a single RDF file into Blazegraph.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to RDF file</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def load_file(self, filepath: str) -&gt; bool:\n    \"\"\"\n    Load a single RDF file into Blazegraph.\n\n    Args:\n        filepath: Path to RDF file\n\n    Returns:\n        True if loaded successfully\n    \"\"\"\n    load_success = False\n    try:\n        with open(filepath, \"rb\") as f:\n            result = self._make_request(\n                \"POST\",\n                self.config.sparql_url,\n                headers={\"Content-Type\": \"text/turtle\"},\n                data=f.read(),\n                timeout=300,\n            )\n\n        if result[\"success\"]:\n            self.log.log(\"\u2705\", self.name, f\"Loaded {filepath}\")\n            load_success = True\n        else:\n            error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n            self.log.log(\n                \"\u274c\", self.name, f\"Failed to load {filepath}: {error_msg}\"\n            )\n            load_success = False\n\n    except Exception as e:\n        self.log.log(\n            \"\u274c\", self.name, f\"Exception loading {filepath}: {e}\"\n        )\n        load_success = False\n\n    return load_success\n</code></pre>"},{"location":"#omnigraph.sparql_server.Blazegraph.load_files_bulk","title":"<code>load_files_bulk(file_list)</code>","text":"<p>Load multiple files using Blazegraph's bulk loader REST API.</p> <p>Parameters:</p> Name Type Description Default <code>file_list</code> <code>list</code> <p>List of file paths to load</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def load_files_bulk(self, file_list: list) -&gt; bool:\n    \"\"\"\n    Load multiple files using Blazegraph's bulk loader REST API.\n\n    Args:\n        file_list: List of file paths to load\n\n    Returns:\n        True if loaded successfully\n    \"\"\"\n    bulk_load_success = False\n\n    if not file_list:\n        bulk_load_success = False\n    else:\n        # Convert to absolute paths\n        abs_paths = [str(Path(f).absolute()) for f in file_list]\n\n        properties = f\"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n        &lt;properties&gt;\n            &lt;entry key=\"format\"&gt;turtle&lt;/entry&gt;\n            &lt;entry key=\"quiet\"&gt;false&lt;/entry&gt;\n            &lt;entry key=\"verbose\"&gt;1&lt;/entry&gt;\n            &lt;entry key=\"namespace\"&gt;kb&lt;/entry&gt;\n            &lt;entry key=\"fileOrDirs\"&gt;{','.join(abs_paths)}&lt;/entry&gt;\n        &lt;/properties&gt;\"\"\"\n\n        result = self._make_request(\n            \"POST\",\n            self.dataloader_url,\n            headers={\"Content-Type\": \"application/xml\"},\n            data=properties,\n            timeout=3600,\n        )\n\n        if result[\"success\"]:\n            self.log.log(\n                \"\u2705\", self.container_name, f\"Bulk loaded {len(file_list)} files\"\n            )\n            bulk_load_success = True\n        else:\n            error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n            self.log.log(\n                \"\u274c\", self.container_name, f\"Bulk load failed: {error_msg}\"\n            )\n            bulk_load_success = False\n\n    return bulk_load_success\n</code></pre>"},{"location":"#omnigraph.sparql_server.Blazegraph.status","title":"<code>status()</code>","text":"<p>Get Blazegraph status information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with status information, empty dict if error</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def status(self) -&gt; dict:\n    \"\"\"\n    Get Blazegraph status information.\n\n    Returns:\n        Dictionary with status information, empty dict if error\n    \"\"\"\n    status_dict = {}\n\n    result = self._make_request(\"GET\", self.config.status_url, timeout=2)\n\n    if result[\"success\"]:\n        status_dict[\"status\"] = \"ready\"\n        html_content = result[\"content\"]\n        name_value_pattern = r'(?:&lt;span id=\"(?P&lt;name1&gt;[^\"]+)\"&gt;(?P&lt;value1&gt;[^&lt;]+)&lt;/span[^&gt;]*&gt;|&amp;#47;(?P&lt;name2&gt;[^=]+)=(?P&lt;value2&gt;[^\\s&amp;#]+))'\n        matches = re.finditer(name_value_pattern, html_content, re.DOTALL)\n\n        for match in matches:\n            for name_group, value_group in {\n                \"name1\": \"value1\",\n                \"name2\": \"value2\",\n            }.items():\n                name = match.group(name_group)\n                if name:\n                    value = match.group(value_group)\n                    sanitized_value = value.replace(\"&lt;/p\", \"\").replace(\"&amp;#47;\", \"/\")\n                    sanitized_name = name.replace(\"-\", \"_\").replace(\"/\", \"_\")\n                    sanitized_name = sanitized_name.replace(\"&amp;#47;\", \"/\")\n                    if not sanitized_name.startswith(\"/\"):\n                        status_dict[sanitized_name] = sanitized_value\n                    break\n    else:\n        if result.get(\"error\"):\n            status_dict[\"status\"] = f\"error: {result['error']}\"\n        else:\n            status_dict[\"status\"] = f\"status_code: {result['status_code']}\"\n\n    return status_dict\n</code></pre>"},{"location":"#omnigraph.sparql_server.Blazegraph.test_geosparql","title":"<code>test_geosparql()</code>","text":"<p>Test if GeoSPARQL functions work.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if GeoSPARQL is available</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def test_geosparql(self) -&gt; bool:\n    \"\"\"\n    Test if GeoSPARQL functions work.\n\n    Returns:\n        True if GeoSPARQL is available\n    \"\"\"\n    test_query = \"\"\"\n    PREFIX geo: &lt;http://www.opengis.net/ont/geosparql#&gt;\n    PREFIX geof: &lt;http://www.opengis.net/def/function/geosparql/&gt;\n\n    SELECT * WHERE {\n        BIND(geof:distance(\"POINT(0 0)\"^^geo:wktLiteral, \"POINT(1 1)\"^^geo:wktLiteral) AS ?dist)\n    } LIMIT 1\n    \"\"\"\n\n    result = self._make_request(\n        \"POST\",\n        self.sparql_url,\n        data={\"query\": test_query},\n        headers={\"Accept\": \"application/sparql-results+json\"},\n        timeout=10,\n    )\n\n    geosparql_available = result[\"success\"]\n    return geosparql_available\n</code></pre>"},{"location":"#omnigraph.sparql_server.BlazegraphConfig","title":"<code>BlazegraphConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ServerConfig</code></p> <p>Blazegraph configuration</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>@dataclass\nclass BlazegraphConfig(ServerConfig):\n    \"\"\"\n    Blazegraph configuration\n    \"\"\"\n    def __post_init__(self):\n        super().__post_init__()\n        blazegraph_base = f\"{self.base_url}/bigdata\"\n        self.status_url = f\"{blazegraph_base}/status\"\n        self.sparql_url = f\"{blazegraph_base}/namespace/kb/sparql\"\n        self.dataloader_url = f\"{blazegraph_base}/dataloader\"\n        self.docker_run_command = f\"docker run -d --name {self.container_name} -p {self.port}:8080 {self.image}\"\n</code></pre>"},{"location":"#omnigraph.sparql_server.QLever","title":"<code>QLever</code>","text":"<p>               Bases: <code>SparqlServer</code></p> <p>Dockerized QLever SPARQL server</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>class QLever(SparqlServer):\n    \"\"\"\n    Dockerized QLever SPARQL server\n    \"\"\"\n\n    def __init__(\n        self,\n        container_name: str = \"qlever\",\n        image: str = \"adfreiburg/qlever\",\n        data_dir: str = None,\n        dataset: str = \"olympics\",\n        port: int = 7001,\n        log: Log = None,\n        shell: Shell = None,\n        debug: bool = False,\n    ):\n        \"\"\"\n        Initialize the QLever manager.\n\n        Args:\n            container_name: Docker container name\n            image: Docker image to use\n            port: Port for QLever web interface\n            data_dir: where to keep the data\n            dataset(str): a default dataset to be loaded\n            log: Log instance for logging\n            shell: Shell instance for Docker commands\n            debug: Enable debug output\n        \"\"\"\n        if not data_dir:\n            raise ValueError(\"Data directory needs to be specified\")\n        self.data_dir = data_dir\n        self.dataset = dataset\n        super().__init__(container_name, image, port, log, shell, debug)\n\n    def start(self, show_progress: bool = True) -&gt; bool:\n        \"\"\"\n        Start QLever using proper workflow.\n        \"\"\"\n        # Use base class start to get container running\n        started = super().start(show_progress=show_progress)\n        if started and self.dataset:\n            # Run QLever setup workflow\n            setup_cmd = (\n                f\"docker exec {self.container_name} qlever setup-config {self.dataset}\"\n            )\n            self._run_shell_command(setup_cmd)\n\n            get_data_cmd = f\"docker exec {self.container_name} qlever get-data\"\n            self._run_shell_command(get_data_cmd)\n\n            index_cmd = f\"docker exec {self.container_name} qlever index\"\n            self._run_shell_command(index_cmd)\n\n            start_cmd = f\"docker exec {self.container_name} qlever start\"\n            self._run_shell_command(start_cmd)\n\n        return started\n\n    def status(self) -&gt; dict:\n        \"\"\"\n        Get QLever status information.\n\n        Returns:\n            Dictionary with status information, empty dict if error\n        \"\"\"\n        status_dict = {}\n        result = self._make_request(\"GET\", self.status_url, timeout=2)\n\n        if result[\"success\"]:\n            status_dict[\"status\"] = \"ready\"\n            try:\n                import json\n\n                status_data = json.loads(result[\"content\"])\n                status_dict.update(status_data)\n            except json.JSONDecodeError:\n                status_dict[\"raw_content\"] = result[\"content\"]\n        else:\n            if result.get(\"error\"):\n                status_dict[\"status\"] = f\"error: {result['error']}\"\n            else:\n                status_dict[\"status\"] = f\"status_code: {result['status_code']}\"\n\n        return status_dict\n\n    def load_file(self, filepath: str) -&gt; bool:\n        \"\"\"\n        Load a single RDF file into QLever.\n\n        Args:\n            filepath: Path to RDF file\n\n        Returns:\n            True if loaded successfully\n        \"\"\"\n        load_success = False\n        try:\n            with open(filepath, \"rb\") as f:\n                result = self._make_request(\n                    \"POST\",\n                    f\"{self.base_url}/api/upload\",\n                    files={\"file\": f},\n                    timeout=300,\n                )\n\n            if result[\"success\"]:\n                self.log.log(\"\u2705\", self.container_name, f\"Loaded {filepath}\")\n                load_success = True\n            else:\n                error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n                self.log.log(\n                    \"\u274c\", self.container_name, f\"Failed to load {filepath}: {error_msg}\"\n                )\n                load_success = False\n\n        except Exception as e:\n            self.log.log(\n                \"\u274c\", self.container_name, f\"Exception loading {filepath}: {e}\"\n            )\n            load_success = False\n\n        return load_success\n\n    def load_dump_files(\n        self, file_pattern: str = \"dump_*.ttl\", use_bulk: bool = True\n    ) -&gt; int:\n        \"\"\"\n        Load all dump files matching pattern.\n\n        Args:\n            file_pattern: Glob pattern for dump files\n            use_bulk: Use bulk loader if True, individual files if False\n\n        Returns:\n            Number of files loaded successfully\n        \"\"\"\n        files = sorted(glob.glob(file_pattern))\n        loaded_count = 0\n\n        if not files:\n            self.log.log(\n                \"\u26a0\ufe0f\",\n                self.container_name,\n                f\"No files found matching pattern: {file_pattern}\",\n            )\n            loaded_count = 0\n        else:\n            self.log.log(\"\u2705\", self.container_name, f\"Found {len(files)} files to load\")\n\n            # QLever typically loads files individually\n            loaded_count = 0\n            for filepath in tqdm(files, desc=\"Loading files\"):\n                file_result = self.load_file(filepath)\n                if file_result:\n                    loaded_count += 1\n                else:\n                    self.log.log(\n                        \"\u274c\", self.container_name, f\"Failed to load: {filepath}\"\n                    )\n\n        return loaded_count\n</code></pre>"},{"location":"#omnigraph.sparql_server.QLever.__init__","title":"<code>__init__(container_name='qlever', image='adfreiburg/qlever', data_dir=None, dataset='olympics', port=7001, log=None, shell=None, debug=False)</code>","text":"<p>Initialize the QLever manager.</p> <p>Parameters:</p> Name Type Description Default <code>container_name</code> <code>str</code> <p>Docker container name</p> <code>'qlever'</code> <code>image</code> <code>str</code> <p>Docker image to use</p> <code>'adfreiburg/qlever'</code> <code>port</code> <code>int</code> <p>Port for QLever web interface</p> <code>7001</code> <code>data_dir</code> <code>str</code> <p>where to keep the data</p> <code>None</code> <code>dataset(str)</code> <p>a default dataset to be loaded</p> required <code>log</code> <code>Log</code> <p>Log instance for logging</p> <code>None</code> <code>shell</code> <code>Shell</code> <p>Shell instance for Docker commands</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug output</p> <code>False</code> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def __init__(\n    self,\n    container_name: str = \"qlever\",\n    image: str = \"adfreiburg/qlever\",\n    data_dir: str = None,\n    dataset: str = \"olympics\",\n    port: int = 7001,\n    log: Log = None,\n    shell: Shell = None,\n    debug: bool = False,\n):\n    \"\"\"\n    Initialize the QLever manager.\n\n    Args:\n        container_name: Docker container name\n        image: Docker image to use\n        port: Port for QLever web interface\n        data_dir: where to keep the data\n        dataset(str): a default dataset to be loaded\n        log: Log instance for logging\n        shell: Shell instance for Docker commands\n        debug: Enable debug output\n    \"\"\"\n    if not data_dir:\n        raise ValueError(\"Data directory needs to be specified\")\n    self.data_dir = data_dir\n    self.dataset = dataset\n    super().__init__(container_name, image, port, log, shell, debug)\n</code></pre>"},{"location":"#omnigraph.sparql_server.QLever.load_dump_files","title":"<code>load_dump_files(file_pattern='dump_*.ttl', use_bulk=True)</code>","text":"<p>Load all dump files matching pattern.</p> <p>Parameters:</p> Name Type Description Default <code>file_pattern</code> <code>str</code> <p>Glob pattern for dump files</p> <code>'dump_*.ttl'</code> <code>use_bulk</code> <code>bool</code> <p>Use bulk loader if True, individual files if False</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of files loaded successfully</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def load_dump_files(\n    self, file_pattern: str = \"dump_*.ttl\", use_bulk: bool = True\n) -&gt; int:\n    \"\"\"\n    Load all dump files matching pattern.\n\n    Args:\n        file_pattern: Glob pattern for dump files\n        use_bulk: Use bulk loader if True, individual files if False\n\n    Returns:\n        Number of files loaded successfully\n    \"\"\"\n    files = sorted(glob.glob(file_pattern))\n    loaded_count = 0\n\n    if not files:\n        self.log.log(\n            \"\u26a0\ufe0f\",\n            self.container_name,\n            f\"No files found matching pattern: {file_pattern}\",\n        )\n        loaded_count = 0\n    else:\n        self.log.log(\"\u2705\", self.container_name, f\"Found {len(files)} files to load\")\n\n        # QLever typically loads files individually\n        loaded_count = 0\n        for filepath in tqdm(files, desc=\"Loading files\"):\n            file_result = self.load_file(filepath)\n            if file_result:\n                loaded_count += 1\n            else:\n                self.log.log(\n                    \"\u274c\", self.container_name, f\"Failed to load: {filepath}\"\n                )\n\n    return loaded_count\n</code></pre>"},{"location":"#omnigraph.sparql_server.QLever.load_file","title":"<code>load_file(filepath)</code>","text":"<p>Load a single RDF file into QLever.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to RDF file</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def load_file(self, filepath: str) -&gt; bool:\n    \"\"\"\n    Load a single RDF file into QLever.\n\n    Args:\n        filepath: Path to RDF file\n\n    Returns:\n        True if loaded successfully\n    \"\"\"\n    load_success = False\n    try:\n        with open(filepath, \"rb\") as f:\n            result = self._make_request(\n                \"POST\",\n                f\"{self.base_url}/api/upload\",\n                files={\"file\": f},\n                timeout=300,\n            )\n\n        if result[\"success\"]:\n            self.log.log(\"\u2705\", self.container_name, f\"Loaded {filepath}\")\n            load_success = True\n        else:\n            error_msg = result.get(\"error\", f\"HTTP {result['status_code']}\")\n            self.log.log(\n                \"\u274c\", self.container_name, f\"Failed to load {filepath}: {error_msg}\"\n            )\n            load_success = False\n\n    except Exception as e:\n        self.log.log(\n            \"\u274c\", self.container_name, f\"Exception loading {filepath}: {e}\"\n        )\n        load_success = False\n\n    return load_success\n</code></pre>"},{"location":"#omnigraph.sparql_server.QLever.start","title":"<code>start(show_progress=True)</code>","text":"<p>Start QLever using proper workflow.</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def start(self, show_progress: bool = True) -&gt; bool:\n    \"\"\"\n    Start QLever using proper workflow.\n    \"\"\"\n    # Use base class start to get container running\n    started = super().start(show_progress=show_progress)\n    if started and self.dataset:\n        # Run QLever setup workflow\n        setup_cmd = (\n            f\"docker exec {self.container_name} qlever setup-config {self.dataset}\"\n        )\n        self._run_shell_command(setup_cmd)\n\n        get_data_cmd = f\"docker exec {self.container_name} qlever get-data\"\n        self._run_shell_command(get_data_cmd)\n\n        index_cmd = f\"docker exec {self.container_name} qlever index\"\n        self._run_shell_command(index_cmd)\n\n        start_cmd = f\"docker exec {self.container_name} qlever start\"\n        self._run_shell_command(start_cmd)\n\n    return started\n</code></pre>"},{"location":"#omnigraph.sparql_server.QLever.status","title":"<code>status()</code>","text":"<p>Get QLever status information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with status information, empty dict if error</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def status(self) -&gt; dict:\n    \"\"\"\n    Get QLever status information.\n\n    Returns:\n        Dictionary with status information, empty dict if error\n    \"\"\"\n    status_dict = {}\n    result = self._make_request(\"GET\", self.status_url, timeout=2)\n\n    if result[\"success\"]:\n        status_dict[\"status\"] = \"ready\"\n        try:\n            import json\n\n            status_data = json.loads(result[\"content\"])\n            status_dict.update(status_data)\n        except json.JSONDecodeError:\n            status_dict[\"raw_content\"] = result[\"content\"]\n    else:\n        if result.get(\"error\"):\n            status_dict[\"status\"] = f\"error: {result['error']}\"\n        else:\n            status_dict[\"status\"] = f\"status_code: {result['status_code']}\"\n\n    return status_dict\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer","title":"<code>SparqlServer</code>","text":"<p>Base class for dockerized SPARQL servers</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>class SparqlServer:\n    \"\"\"\n    Base class for dockerized SPARQL servers\n    \"\"\"\n\n    def __init__(\n        self,\n        config:ServerConfig,\n        log: Log = None,\n        shell: Shell = None,\n        debug: bool = False,\n\n    ):\n        \"\"\"\n        Initialize the SPARQL server manager.\n\n        \"\"\"\n        if log is None:\n            log = Log()\n        self.log = log\n        self.config=config\n        self.name=self.config.name\n        self.debug = debug\n\n        if shell is None:\n            shell = Shell()\n        self.shell = shell\n\n        # Subclasses must set these URLs\n        if self.config.sparql_url:\n            self.sparql = SPARQL(self.config.sparql_url)\n\n    def _make_request(self, method: str, url: str, timeout: int = 30, **kwargs) -&gt; dict:\n        \"\"\"\n        Helper function for making HTTP requests with consistent error handling.\n\n        Args:\n            method: HTTP method (GET, POST, etc.)\n            url: Request URL\n            timeout: Request timeout in seconds\n            **kwargs: Additional arguments for requests\n\n        Returns:\n            Dictionary with 'success', 'status_code', 'content', and optional 'error'\n        \"\"\"\n        request_result = {}\n        try:\n            response = requests.request(method, url, timeout=timeout, **kwargs)\n            request_result = {\n                \"success\": response.status_code in [200, 204],\n                \"status_code\": response.status_code,\n                \"content\": response.text,\n                \"response\": response,\n            }\n        except Exception as e:\n            request_result = {\n                \"success\": False,\n                \"status_code\": None,\n                \"content\": None,\n                \"error\": str(e),\n            }\n        return request_result\n\n    def run_shell_command(\n        self, command: str, success_msg: str = None, error_msg: str = None\n    ) -&gt; bool:\n        \"\"\"\n        Helper function for running shell commands with consistent error handling.\n\n        Args:\n            command: Shell command to run\n            success_msg: Message to log on success\n            error_msg: Message to log on error\n\n        Returns:\n            True if command succeeded (returncode 0)\n        \"\"\"\n        container_name = self.config.container_name\n        command_success = False\n        try:\n            result = self.shell.run(command, debug=self.debug)\n            if result.returncode == 0:\n                if success_msg:\n                    self.log.log(\"\u2705\", container_name, success_msg)\n                command_success = True\n            else:\n                error_detail = error_msg or f\"Command failed: {command}\"\n                if result.stderr:\n                    error_detail += f\" - {result.stderr}\"\n                self.log.log(\"\u274c\", container_name, error_detail)\n                command_success = False\n        except Exception as e:\n            self.log.log(\n                \"\u274c\", container_name, f\"Exception running command '{command}': {e}\"\n            )\n            command_success = False\n        return command_success\n\n    def start(self, show_progress: bool = True) -&gt; bool:\n        \"\"\"\n        Start SPARQL server in Docker container.\n\n        Args:\n            show_progress: Show progress bar while waiting\n\n        Returns:\n            True if started successfully\n        \"\"\"\n        container_name = self.config.container_name\n        server_name = self.config.name\n        start_success = False\n        try:\n            if self.is_running():\n                self.log.log(\n                    \"\u2705\",\n                    container_name,\n                    f\"Container {container_name} is already running\",\n                )\n                start_success = self.wait_until_ready(show_progress=show_progress)\n            elif self.exists():\n                self.log.log(\n                    \"\u2705\",\n                    container_name,\n                    f\"Container {container_name} exists, starting...\",\n                )\n                start_cmd = f\"docker start {container_name}\"\n                start_result = self.run_shell_command(\n                    start_cmd,\n                    error_msg=f\"Failed to start container {container_name}\",\n                )\n                if start_result:\n                    start_success = self.wait_until_ready(show_progress=show_progress)\n                else:\n                    start_success = False\n            else:\n                self.log.log(\n                    \"\u2705\",\n                    container_name,\n                    f\"Creating new {server_name} container {container_name}...\",\n                )\n                create_cmd = self.config.docker_run_command\n                create_result = self.run_shell_command(\n                    create_cmd,\n                    error_msg=f\"Failed to create container {container_name}\",\n                )\n                if create_result:\n                    start_success = self.wait_until_ready(show_progress=show_progress)\n                else:\n                    start_success = False\n        except Exception as e:\n            self.log.log(\n                \"\u274c\",\n                container_name,\n                f\"Error starting {server_name}: {e}\",\n            )\n            start_success = False\n        return start_success\n\n    def count_triples(self) -&gt; int:\n        \"\"\"\n        Count total triples in the SPARQL server.\n\n        Returns:\n            Number of triples\n        \"\"\"\n        count_query = \"SELECT (COUNT(*) AS ?count) WHERE { ?s ?p ?o }\"\n        result = self.sparql.getValue(count_query, \"count\")\n        triple_count = int(result) if result else 0\n        return triple_count\n\n    def wait_until_ready(self, timeout: int = 30, show_progress: bool = False) -&gt; bool:\n        \"\"\"\n        Wait for server to be ready.\n\n        Args:\n            timeout: Maximum seconds to wait\n            show_progress: Show progress bar while waiting\n\n        Returns:\n            True if ready within timeout\n        \"\"\"\n        container_name = self.config.container_name\n        server_name = self.config.name\n        status_url = self.config.status_url\n        base_url = self.config.base_url\n\n        self.log.log(\n            \"\u2705\",\n            container_name,\n            f\"Waiting for {server_name} to start ... {status_url}\",\n        )\n\n        pbar = None\n        if show_progress:\n            pbar = tqdm(\n                total=timeout, desc=f\"Waiting for {server_name}\", unit=\"s\"\n            )\n\n        ready_status = False\n        for i in range(timeout):\n            status_dict = self.status()\n            if status_dict.get(\"status\") == \"ready\":\n                if show_progress and pbar:\n                    pbar.close()\n                self.log.log(\n                    \"\u2705\",\n                    container_name,\n                    f\"{server_name} ready at {base_url}\",\n                )\n                ready_status = True\n                break\n\n            if show_progress and pbar:\n                pbar.update(1)\n            time.sleep(1)\n\n        if not ready_status:\n            if show_progress and pbar:\n                pbar.close()\n            self.log.log(\n                \"\u26a0\ufe0f\",\n                container_name,\n                f\"Timeout waiting for {server_name} to start after {timeout}s\",\n            )\n\n        return ready_status\n\n    def is_running(self) -&gt; bool:\n        \"\"\"\n        Check if container is currently running.\n\n        Returns:\n            True if container is running\n        \"\"\"\n        running_cmd = (\n            f'docker ps --filter \"name={self.config.container_name}\" --format \"{{{{.Names}}}}\"'\n        )\n        result = self.shell.run(running_cmd, debug=self.debug)\n        is_container_running = self.config.container_name in result.stdout\n        return is_container_running\n\n    def exists(self) -&gt; bool:\n        \"\"\"\n        Check if container exists (running or stopped).\n\n        Returns:\n            True if container exists\n        \"\"\"\n        container_name=self.config.container_name\n        check_cmd = f'docker ps -a --filter \"name={container_name}\" --format \"{{{{.Names}}}}\"'\n        result = self.shell.run(check_cmd, debug=self.debug)\n        if result.stderr:\n            self.log.log(\"\u274c\", container_name, result.stderr)\n        container_exists = container_name in result.stdout\n        return container_exists\n\n    def stop(self) -&gt; bool:\n        \"\"\"\n        Stop the server container.\n\n        Returns:\n            True if stopped successfully\n        \"\"\"\n        stop_cmd = f\"docker stop {self.container_name}\"\n        stop_success = self._run_shell_command(\n            stop_cmd,\n            success_msg=f\"Stopped container {self.container_name}\",\n            error_msg=f\"Failed to stop container {self.container_name}\",\n        )\n        return stop_success\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.__init__","title":"<code>__init__(config, log=None, shell=None, debug=False)</code>","text":"<p>Initialize the SPARQL server manager.</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def __init__(\n    self,\n    config:ServerConfig,\n    log: Log = None,\n    shell: Shell = None,\n    debug: bool = False,\n\n):\n    \"\"\"\n    Initialize the SPARQL server manager.\n\n    \"\"\"\n    if log is None:\n        log = Log()\n    self.log = log\n    self.config=config\n    self.name=self.config.name\n    self.debug = debug\n\n    if shell is None:\n        shell = Shell()\n    self.shell = shell\n\n    # Subclasses must set these URLs\n    if self.config.sparql_url:\n        self.sparql = SPARQL(self.config.sparql_url)\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.count_triples","title":"<code>count_triples()</code>","text":"<p>Count total triples in the SPARQL server.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of triples</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def count_triples(self) -&gt; int:\n    \"\"\"\n    Count total triples in the SPARQL server.\n\n    Returns:\n        Number of triples\n    \"\"\"\n    count_query = \"SELECT (COUNT(*) AS ?count) WHERE { ?s ?p ?o }\"\n    result = self.sparql.getValue(count_query, \"count\")\n    triple_count = int(result) if result else 0\n    return triple_count\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.exists","title":"<code>exists()</code>","text":"<p>Check if container exists (running or stopped).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if container exists</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"\n    Check if container exists (running or stopped).\n\n    Returns:\n        True if container exists\n    \"\"\"\n    container_name=self.config.container_name\n    check_cmd = f'docker ps -a --filter \"name={container_name}\" --format \"{{{{.Names}}}}\"'\n    result = self.shell.run(check_cmd, debug=self.debug)\n    if result.stderr:\n        self.log.log(\"\u274c\", container_name, result.stderr)\n    container_exists = container_name in result.stdout\n    return container_exists\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.is_running","title":"<code>is_running()</code>","text":"<p>Check if container is currently running.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if container is running</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def is_running(self) -&gt; bool:\n    \"\"\"\n    Check if container is currently running.\n\n    Returns:\n        True if container is running\n    \"\"\"\n    running_cmd = (\n        f'docker ps --filter \"name={self.config.container_name}\" --format \"{{{{.Names}}}}\"'\n    )\n    result = self.shell.run(running_cmd, debug=self.debug)\n    is_container_running = self.config.container_name in result.stdout\n    return is_container_running\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.run_shell_command","title":"<code>run_shell_command(command, success_msg=None, error_msg=None)</code>","text":"<p>Helper function for running shell commands with consistent error handling.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Shell command to run</p> required <code>success_msg</code> <code>str</code> <p>Message to log on success</p> <code>None</code> <code>error_msg</code> <code>str</code> <p>Message to log on error</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if command succeeded (returncode 0)</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def run_shell_command(\n    self, command: str, success_msg: str = None, error_msg: str = None\n) -&gt; bool:\n    \"\"\"\n    Helper function for running shell commands with consistent error handling.\n\n    Args:\n        command: Shell command to run\n        success_msg: Message to log on success\n        error_msg: Message to log on error\n\n    Returns:\n        True if command succeeded (returncode 0)\n    \"\"\"\n    container_name = self.config.container_name\n    command_success = False\n    try:\n        result = self.shell.run(command, debug=self.debug)\n        if result.returncode == 0:\n            if success_msg:\n                self.log.log(\"\u2705\", container_name, success_msg)\n            command_success = True\n        else:\n            error_detail = error_msg or f\"Command failed: {command}\"\n            if result.stderr:\n                error_detail += f\" - {result.stderr}\"\n            self.log.log(\"\u274c\", container_name, error_detail)\n            command_success = False\n    except Exception as e:\n        self.log.log(\n            \"\u274c\", container_name, f\"Exception running command '{command}': {e}\"\n        )\n        command_success = False\n    return command_success\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.start","title":"<code>start(show_progress=True)</code>","text":"<p>Start SPARQL server in Docker container.</p> <p>Parameters:</p> Name Type Description Default <code>show_progress</code> <code>bool</code> <p>Show progress bar while waiting</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if started successfully</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def start(self, show_progress: bool = True) -&gt; bool:\n    \"\"\"\n    Start SPARQL server in Docker container.\n\n    Args:\n        show_progress: Show progress bar while waiting\n\n    Returns:\n        True if started successfully\n    \"\"\"\n    container_name = self.config.container_name\n    server_name = self.config.name\n    start_success = False\n    try:\n        if self.is_running():\n            self.log.log(\n                \"\u2705\",\n                container_name,\n                f\"Container {container_name} is already running\",\n            )\n            start_success = self.wait_until_ready(show_progress=show_progress)\n        elif self.exists():\n            self.log.log(\n                \"\u2705\",\n                container_name,\n                f\"Container {container_name} exists, starting...\",\n            )\n            start_cmd = f\"docker start {container_name}\"\n            start_result = self.run_shell_command(\n                start_cmd,\n                error_msg=f\"Failed to start container {container_name}\",\n            )\n            if start_result:\n                start_success = self.wait_until_ready(show_progress=show_progress)\n            else:\n                start_success = False\n        else:\n            self.log.log(\n                \"\u2705\",\n                container_name,\n                f\"Creating new {server_name} container {container_name}...\",\n            )\n            create_cmd = self.config.docker_run_command\n            create_result = self.run_shell_command(\n                create_cmd,\n                error_msg=f\"Failed to create container {container_name}\",\n            )\n            if create_result:\n                start_success = self.wait_until_ready(show_progress=show_progress)\n            else:\n                start_success = False\n    except Exception as e:\n        self.log.log(\n            \"\u274c\",\n            container_name,\n            f\"Error starting {server_name}: {e}\",\n        )\n        start_success = False\n    return start_success\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.stop","title":"<code>stop()</code>","text":"<p>Stop the server container.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if stopped successfully</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def stop(self) -&gt; bool:\n    \"\"\"\n    Stop the server container.\n\n    Returns:\n        True if stopped successfully\n    \"\"\"\n    stop_cmd = f\"docker stop {self.container_name}\"\n    stop_success = self._run_shell_command(\n        stop_cmd,\n        success_msg=f\"Stopped container {self.container_name}\",\n        error_msg=f\"Failed to stop container {self.container_name}\",\n    )\n    return stop_success\n</code></pre>"},{"location":"#omnigraph.sparql_server.SparqlServer.wait_until_ready","title":"<code>wait_until_ready(timeout=30, show_progress=False)</code>","text":"<p>Wait for server to be ready.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Maximum seconds to wait</p> <code>30</code> <code>show_progress</code> <code>bool</code> <p>Show progress bar while waiting</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if ready within timeout</p> Source code in <code>omnigraph/sparql_server.py</code> <pre><code>def wait_until_ready(self, timeout: int = 30, show_progress: bool = False) -&gt; bool:\n    \"\"\"\n    Wait for server to be ready.\n\n    Args:\n        timeout: Maximum seconds to wait\n        show_progress: Show progress bar while waiting\n\n    Returns:\n        True if ready within timeout\n    \"\"\"\n    container_name = self.config.container_name\n    server_name = self.config.name\n    status_url = self.config.status_url\n    base_url = self.config.base_url\n\n    self.log.log(\n        \"\u2705\",\n        container_name,\n        f\"Waiting for {server_name} to start ... {status_url}\",\n    )\n\n    pbar = None\n    if show_progress:\n        pbar = tqdm(\n            total=timeout, desc=f\"Waiting for {server_name}\", unit=\"s\"\n        )\n\n    ready_status = False\n    for i in range(timeout):\n        status_dict = self.status()\n        if status_dict.get(\"status\") == \"ready\":\n            if show_progress and pbar:\n                pbar.close()\n            self.log.log(\n                \"\u2705\",\n                container_name,\n                f\"{server_name} ready at {base_url}\",\n            )\n            ready_status = True\n            break\n\n        if show_progress and pbar:\n            pbar.update(1)\n        time.sleep(1)\n\n    if not ready_status:\n        if show_progress and pbar:\n            pbar.close()\n        self.log.log(\n            \"\u26a0\ufe0f\",\n            container_name,\n            f\"Timeout waiting for {server_name} to start after {timeout}s\",\n        )\n\n    return ready_status\n</code></pre>"}]}